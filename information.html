<!doctype html>
<!--
	Jericho Comms - Information-theoretically secure communications
	Copyright (c) 2013-2015  Joshua M. David

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation in version 3 of the License.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see [http://www.gnu.org/licenses/].
-->
<html lang="en">
	<head>
		<title>Jericho Comms&trade; - Technical Information</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">		
		<meta name="description" content="Jericho Comms is a secure group chat program using one-time pads.">
		<meta name="viewport" content="width=720, maximum-scale=1.0, user-scalable=yes">

		<link rel="stylesheet" href="css/reset.css" type="text/css">
		<link rel="stylesheet" href="css/global.css" type="text/css">
		<link rel="stylesheet" href="css/print.css" type="text/css" media="print">
		
		<!--[if IE]>
			<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<![endif]-->		
		<!--[if IE 7]>
			<link rel="stylesheet" href="css/ie7.css" type="text/css">
		<![endif]-->
		<!--[if IE 8]>
			<link rel="stylesheet" href="css/ie8.css" type="text/css">
		<![endif]-->
	</head>
	<body>
		<div class="topSection">
			<div class="topBanner">
				<a class="logo" href="index.html" title="Homepage"></a>			
				<div class="mainNav">
					<ul>						
						<li><a href="information.html">Technical information</a></li>
						<li><a href="download.html">Download</a></li>
						<li><a href="https://github.com/joshua-m-david/jerichoencryption">Source code</a></li>
						<li><a href="installation.html">How to install</a></li>
						<li><a href="usage.html">How to use</a></li>
						<li><a href="faq.html">FAQ</a></li>			
					</ul>
				</div>
			</div>
		</div>
		<div class="content">
			<div class="page infoPage">
				<div class="information">
					<div class="printableHeader printable">
						<div class="title">Jericho Comms&trade;</div>
						<div class="version">Version 1.5</div>
						<div class="date">9 September 2015</div>
						<div class="author">Joshua M. David</div>
                        <div class="email">joshua.m.david [at] tutanota.de</div>
					</div>
					<div class="printableAbstract printable">
						<h2 id="abstract">Abstract</h2>
						<p>
							In the wake of the <a href="https://www.eff.org/nsa-spying">NSA spying revelations</a> it is clear that 
							<u>none</u> of our communications are secure any longer. The <a href="http://en.wikipedia.org/wiki/Nsa">NSA</a> 
							is actively monitoring, collecting, 
							<a href="http://www.theguardian.com/world/2013/sep/05/nsa-gchq-encryption-codes-security">decrypting</a> and 
							<a href="http://www.wired.com/threatlevel/2012/03/ff_nsadatacenter/">indefinitely storing</a> 
							the whole world's communications as it transits their networks. Any traffic passing through 
							any of the <a href="http://en.wikipedia.org/wiki/UKUSA_Agreement">Five Eyes</a> countries (US, UK, Canada, 
							Australia and NZ) is monitored, collected and stored indefinitely. Any and all of your internet 
							traffic, phone calls, email, chat messages and anything else are vulnerable to the Five Eyes spy 
							agencies. This is no longer conspiracy theory, it is actually happening.
						</p>
						<p>
							This is a massive breach of international human rights and it is an attack on the liberty, freedom and 
							privacy of every person on the planet. It has huge implications for our democracy, freedom of the press, 
							attorney-client privilege and freedom of speech. The 
							<a href="http://www.un.org/en/documents/udhr/">Universal Declaration of Human Rights</a> states clearly:
						</p>
						<ul>
							<li>
								<b>Article 3:</b> Everyone has the right to life, <i>liberty</i> and security of person.
							</li>
							<li>
								<b>Article 12:</b> <u>No one</u> shall be subjected to arbitrary interference with his <i>privacy</i>, 
								family, home or <i>correspondence</i>, nor to attacks upon his honour and reputation. Everyone has the 
								right to the protection of the law against such interference or attacks.
							</li>
						</ul>
						<p>
							Jericho Comms is an encrypted group communications program built on the principles of information-theoretic 
							security using true random number generation, one-time message authentication codes and mathematically 
							proven security of the <a href="http://en.wikipedia.org/wiki/One_time_pad">one-time pad</a> cipher. The 
							goal is to deliver a free, open source, plausibly deniable, encrypted communications program 
							for journalists, lawyers, activists and citizens of the world that need <i>high</i> assurances that their 
							communications are free of censorship, control, oppression, totalitarian governments and eavesdropping 
							from the world's most powerful intelligence agencies. To defeat the world's top intelligence agencies, 
							you need to lift your game to their level. That means using encryption that they can <i>never</i> break, 
							regardless of advances in mathematics, quantum physics, cryptanalysis or computing power.
						</p>
						<p>
							The software makes the whole process very simple from generating truly random one-time pads, key management 
							and chatting securely. After a message is sent, the one-time pad used is automatically deleted from the computer. 
							Once received it is also deleted from the server and receiving computers. This prevents the message being 
							decrypted in the future if one of the computers is compromised. If a user thinks their computer is about 
							to become compromised they can also initiate the Auto Nuke feature which will delete the one-time pads 
							from the local database, encrypted messages from the server and the one-time pads from the chat partner's 
							local database. These features combined provide a form of Off The Record encrypted chat. The full 
							source code is available on GitHub at https://github.com/joshua-m-david/jerichoencryption.
						</p>
						<p>
							The main reason why one-time pads are infrequently used outside of government and military networks is 
							that you need truly random data, the key must be at least as long as the message and the one-time pads 
							must be sent through a secure channel e.g. delivered in person. This makes them somewhat inconvenient to 
							use but these are <i>not</i> insurmountable problems. This software aims to solve most of the issues that 
							make using one-time pads difficult. The only minor issue would be delivering the one-time pads to 
							the other user, but <a href="information.html#how-it-works">there are ways</a> to do that easily enough. 
							In today's world of complete surveillance it is necessary to have a shared secret to authenticate the 
							correspondents and have complete assurance you are actually communicating with the right people and not an
							<a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">active Man in the Middle (MITM) attacker</a>. 
							Obviously this software is not a solution for all cryptography problems. It does however solve a specific 
							problem and allows you to communicate securely with your family, friends, colleagues or associates in the 
							future if you have met them at least once and exchanged one-time pads with them.
						</p>						
					</div>
					
					<h1 class="nonPrintable">Technical information</h1>
					<p class="nonPrintable">
						This page is printable and can be downloaded as a signed 
						<a href="files/jericho-v1.5.pdf">PDF white paper</a><sup><a href="files/jericho-v1.5.pdf.asc">[sig]</a></sup>. 
						<i>Note:</i> The links on this page are not currently visible in the document and will be added 
						as references to an appendix at a later date. Image quality in the PDF may also appear 
                        distorted.
					</p>
					
					<h2 id="table-of-contents">Contents</h2>
					<ol class="tableOfContents">
                        <li><a href="#notation">Formulas and notation</a></li>
						<li><a href="#overall-network-architecture">Overall network architecture</a></li>
						<li><a href="#how-it-works">How it works</a></li>
						<li><a href="#configuring-own-server">Server configuration</a></li>
						<li><a href="#server-authentication-protocol">Server authentication protocol</a></li>
						<li><a href="#frustrating-traffic-analysis">Preventing information leakage and traffic analysis</a></li>
						<li><a href="#using-tls">Using TLS/HTTPS</a></li>
						<li><a href="#trng-photo">True Random Number Generator (TRNG)</a></li>
						<li><a href="#output-testing">Testing the TRNG random output</a></li>
						<li><a href="#trng-test-analysis">TRNG tests and analysis</a></li>
						<li><a href="#trng-custom">Custom random data loading</a></li>
						<li><a href="#database-encryption">One-time pad database encryption and authentication</a></li>
						<li><a href="#database-key-wrapping">Protection of database encryption and authentication keys</a></li>
						<li><a href="#pad-storage-export">Pad storage and exporting data</a></li>						
						<li><a href="#using-html5">Using HTML5</a></li>
						<li><a href="#json-rest-api">REST API using JSON</a></li>
						<li><a href="#message-encoding">Message encoding</a></li>
						<li><a href="#encryption-process">Encryption process</a></li>
						<li><a href="#decryption-process">Decryption process</a></li>
						<li><a href="#message-authentication">Message authentication code (MAC)</a></li>
						<li><a href="#auto-nuke-process">Auto nuke process</a></li>
					</ol>
					
					
                    <h2 id="notation">Formulas and notation</h2>
					<p>
						The notation used in this document will use very limited mathematical and cryptographic 
                        formulas and will tend towards explaining the design in plain English rather than mathematical 
                        formulas so that the content is more accessible and understandable by a wider audience.
					</p>
                    <ul class="formulas notation">
                        <li>
                            <b>&oplus;</b> = Bitwise <a href="https://en.wikipedia.org/wiki/Exclusive_disjunction">Exclusive OR</a> 
                            (XOR) operator e.g. 0 &oplus; 1 = 1.
                        </li>
                        <li>
                            <b>||</b> = Concatenation. Usually variables will be converted to the same type and format 
                            before being concatenated together, e.g. for input into a hash function all variables will 
                            be in hexadecimal format.
                        </li>
                        <li>
                            <b>&#215;</b> = Regular multiplication.
                        </li>
                    </ul>
                    
                    
					<h2 id="overall-network-architecture">Overall network architecture</h2>
					<p>
						The following will outline the entire design of the application and how it works. Exact 
						implementation details can be found in the source code which is provided with every download.
					</p>					
					<p class="diagram">
						<a href="img/network-architecture.png">
							<img alt="Network architecture diagram" src="img/network-architecture.png" style="width: 100%">
						</a>
					</p>
					<ul>
						<li>
							One particular point about this client-server architecture is that the clients are the only 
							devices which have the one-time pads (encryption keys). The server effectively only contains 
							encrypted data. The clients operate on a request, response basis. For this reason the clients 
							which have the sensitive encryption keys should have their firewalls configured to block <b>all</b> 
							incoming traffic by default and only receive incoming data as responses to outgoing requests 
							that they have specifically made to the server. The responses from the server are always 
							authenticated using a shared API Key and any malformed or unauthentic responses are immediately 
							discarded. This makes the client machines a lot more resilient to attack and exfiltration of 
							encryption keys. Assuming the client machines are single purpose and are not used for 
							untrusted web browsing or other activities this is a very small attack surface.
						</li>
						<li>
							The server should have a firewall as well which only allows incoming application data on one 
							port and optionally on an SSH port for management. The server application expects a correctly 
							authenticated packet from the client or it discards the request and responds with a 
                            <code>HTTP/1.1 404 Not Found</code> error. Of course there is the potential for a 
                            <a href="https://www.eff.org/cases/eff-v-nsa-odni-vulnerabilities-foia">0-day vulnerability</a> 
                            in the server application layers but compromising the server will not 
							compromise confidentiality or authenticity of messages as they are encrypted end-to-end. If 
							an attacker gained access to the server they could only interfere with the server's operations 
							to block messages from being sent or received at all.
						</li>
					</ul>
					
					
					<h2 id="how-it-works">How it works</h2>
					<ul>
						<li>
							The first user will run a True Random Number Generator included with the software. This is explained 
							further on. This random data is then broken up into separate 
							<a href="http://en.wikipedia.org/wiki/One-time_pad">one-time pads</a>. It is possible to generate 
							enough data for 1900+ messages in under a minute.
						</li>
						<li>
							Each user will be assigned pads for sending messages. This prevents re-use of a pad by another user. 
							<a href="http://en.wikipedia.org/wiki/VENONA_project#Decryption">Re-using a pad</a> can make cryptanalysis 
							possible so it's very important to prevent this. The messaging protocol is explained in depth further on.
						</li>
						<li>
							Once the pads are generated, the program can export the pads for each user to text files. These should 
							be saved onto removable flash media such as MicroSD, SD card, USB thumbdrive, CD, DVD or portable hard 
							drive. There are some <a href="faq.html#extra-security-considerations">other precautions</a> listed 
							in the FAQ such as creating a TrueCrypt volume on the storage media first <i>before</i> copying the 
							pads into it. This saves time in not needing to securely erase the pads or physically destroy the 
							storage media after they have been transferred to the other user.
						</li>
						<li>
							To get the one-time pads to the other users, ideally they will arrange a physical meetup. 
							This is to create a <a href="http://en.wikipedia.org/wiki/Secure_channel">secure channel</a> or 
							<a href="http://en.wikipedia.org/wiki/Air_gap_%28networking%29">air gap</a> to deliver the one-time 
							pads which ensures the encryption keys are not intercepted or compromised by transferring them over an 
							insecure network like the internet. Key exchange is considered out of scope for the program itself as 
							this is the user's responsibility. The best method is to hide in plain sight. Here are a few solutions 
							that will usually work:
							<ul>
								<li>
									 Meeting the users in person for a coffee/drink/lunch/dinner provides an innocent cover for 
									 the exchange of encryption keys. If you are going about your daily activities this is the 
									 least suspicious option and the most likely to succeed.
								</li>
								<li>
									A <a href="http://en.wikipedia.org/wiki/Dead_drop">dead drop</a>. Arrange the time and place 
									of the dead drop (or regularly scheduled dead drops) in person or using another method, but 
									do not arrange this over an insecure channel like the phone or internet.
								</li>
								<li>
									If your country does not inspect internal mail you can hand sign a sealed courier envelope 
									and send it with reasonable assurance that it won't be compromised. If the package appears to 
									be opened on delivery, consider the encryption keys compromised and do not use them. 
									International mail is sometimes opened by 
									<a href="https://en.wikipedia.org/wiki/Customs">Customs</a> so it is not a reliable method. 
									It would not be difficult to hide an encrypted MicroSD within something else though.
								</li>
								<li>
									It is not difficult to get a laptop, portable hard drive, MicroSD card, or SD card through 
									Customs at national or international airports. You can also 
									hide them in your luggage or on your person. If your government generally clones or scans 
									personal phones or computers as you are going through Customs you may need to use 
									<a href="http://en.wikipedia.org/wiki/Steganography_tools">steganography</a> to hide the 
									one-time pads within your vacation photos, videos or other files.
								</li>
								<li>
									Governments and diplomats also have the option of using a 
									<a href="http://en.wikipedia.org/wiki/Diplomatic_bag">diplomatic bag</a> to transfer items to 
									another country which have diplomatic immunity from search or seizure under the Vienna 
									Convention on Diplomatic Relations.
								</li>
							</ul>
							The one-time pads absolutely cannot be sent via a less secure channel such as the internet even if 
							you think you are using the best public key, block or stream cipher encryption there is. Your 
							security will only be as strong as the cipher you used and you lose the 
							<a href="http://en.wikipedia.org/wiki/One-time_pad#Perfect_secrecy">perfect secrecy</a> that the 
							one-time pad provides.<br>
							<br>
							There may be people that complain about having to deliver the one-time pads physically. If you 
							seriously want to take your privacy back, you need to use encryption which the NSA absolutely and 
							unequivocally can't break. If you are willing to trade security for convenience and blindly use the 
							US government's recommended encryption algorithms then you will only receive the amount of privacy 
							they want you to have. The US government does <u>not</u> have your best interests at heart, they want 
							to monitor any and all communications and they will do that by whatever means necessary.
						</li>
						<li>					
							As the one-time pads are in transit it is important to keep them securely on you at all times. Do not 
							leave them anywhere unattended and keep them in a zipped up pocket to prevent pickpockets, and ideally 
							have a <a href="https://en.wikipedia.org/wiki/Tamper-evident">tamper evident</a> seal.
						</li>
						<li>
							Once the one-time pads are safely delivered and the server is set up, each user will load them into 
							the program and begin chatting. There are extra security considerations 
							<a href="faq.html#extra-security-considerations">in the FAQ</a> but it will be important to erase 
							the text file containing the one-time pads from the removable media once they are loaded into the 
							program. Storing the one-time pads and running the software from within an encrypted container on the 
							removable media will help mitigate most issues. Portable versions of 
							<a href="http://www.truecrypt.org/docs/truecrypt-portable">TrueCrypt</a> and 
							<a href="http://portableapps.com/apps/internet/firefox_portable">Firefox</a> can be used for this. 
						</li>
					</ul>
										
					
					<h2 id="configuring-own-server">Server configuration</h2>
					<p>
						The server basically functions as a temporary database store for the encrypted messages. One user leaves encrypted 
						messages on the server and the other users can retrieve them when they are able. If both users are 
						connected at the same time it is possible for realtime chat, plus or minus a few seconds. The messages 
						are removed immediately from the server after they are read by all users.
					</p>
					<p>
						The server is user owned and operated which means users are in complete control of the communications. 
						No-one else knows about the server so this keeps it off the radar of the intelligence agencies, as 
						opposed to having a central server somewhere that everyone on the internet is using. If everyone was 
						using a single server it leaves it as a single point of failure and the intelligence agencies can 
						<a href="https://www.youtube.com/watch?v=pMas0tWc0sg">raid it</a>, 
						<a href="https://en.wikipedia.org/wiki/Tailored_Access_Operations">hack it</a> or 
						<a href="http://www.theguardian.com/commentisfree/2014/may/20/why-did-lavabit-shut-down-snowden-email">shut it down</a> 
						with a court order. There is no useful data for them on the server but they would be able to shut down a 
						lot user's of communications at once, at least until someone set up a new server.
					</p>
					<p>
						The server code provides a <a href="https://en.wikipedia.org/wiki/REST">REST</a> 
						<a href="https://en.wikipedia.org/wiki/API">API</a> using 
						<a href="http://en.wikipedia.org/wiki/JSON">JSON</a> which will run on the 
						<a href="http://en.wikipedia.org/wiki/Apache_HTTP_Server">Apache</a> 
						2.2+ web server, <a href="http://en.wikipedia.org/wiki/Mysql">MySQL</a> 5.5+ database and 
						<a href="http://en.wikipedia.org/wiki/Php">PHP</a> 5.3+ programming language. PHP was chosen because 
						it is a <a href="https://en.wikipedia.org/wiki/Memory_safety">memory safe language</a>, fast to develop in 
						and fast to deploy along with a basic 
						<a href="http://en.wikipedia.org/wiki/LAMP_%28software_bundle%29">LAMP stack</a>. In a future version, 
						the design may be ported to another server side language, database and web server that are considered more 
						secure. The straightforward JSON REST API interface should enable the client to connect with multiple 
						different backend code bases and users can implement the one of their choosing.
					</p>
					<p>
						At the moment, to get the server side running all that is needed is to install a basic 
						<a href="http://en.wikipedia.org/wiki/LAMP_%28software_bundle%29">LAMP stack</a>, copy the server files 
						over to the web root directory, run the database script to create the tables, then finally edit the config 
						file with the server's database and API login credentials. An easy to use guide with screenshots for 
						<a href="http://www.ubuntu.com/server">Ubuntu</a> server <a href="installation-server.html">has been created</a> 
						for this. Users can install a server their own network, or pay for a cheap 
						<a href="https://en.wikipedia.org/wiki/Virtual_private_server">VPS</a> somewhere. It is not recommended 
						to use a VPS in the US to rule out the possibility of the provider being issued with a 
						<a href="https://en.wikipedia.org/wiki/National_security_letter">National Security Letter</a> 
						which would compromise security of the server.
					</p>
					
					
					<h2 id="server-authentication-protocol">Server authentication protocol</h2>
					<p>
						A new protocol from version 1.3 was designed to securely authenticate the requests and responses with the 
						server API. This replaces TLS which secured the server API credentials (username & password) in transit 
						in versions up to 1.2. The reason for this was mainly to simplify installation, 
						<a href="http://www.thoughtcrime.org/blog/ssl-and-the-future-of-authenticity/">avoid Certificate Authorities</a>, 
						have resistance against active <a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">MITM attacks</a> and 
						<a href="http://www.washingtonpost.com/world/national-security/nsa-seeks-to-build-quantum-computer-that-could-crack-most-types-of-encryption/2014/01/02/8fff297e-7195-11e3-8def-a33011492df2_story.html">quantum computers</a>. 
						There have also been major security problems with common TLS implementations such as 
						<a href="http://en.wikipedia.org/wiki/Heartbleed">OpenSSL</a>, 
						<a href="http://arstechnica.com/security/2014/03/critical-crypto-bug-leaves-linux-hundreds-of-apps-open-to-eavesdropping/">GnuTLS</a> and 
						<a href="http://arstechnica.com/security/2014/02/extremely-critical-crypto-flaw-in-ios-may-also-affect-fully-patched-macs/">iOS</a> which 
						have led to a loss in confidence in these programs which have poor code quality and may be hiding 
						other NSA backdoors.
					</p>
					<h3>Design goals</h3>
					<ul>
						<li>
							Authenticate all API requests to the server to verify they are from valid server users.
						</li>
						<li>
							Authenticate all API responses from the server to verify the response came from the legitimate 
							server, not an attacker.
						</li>
						<li>
							Mitigate passive MITM attacks where an attacker tries to steal the API credentials in transit.
						</li>
						<li>
							Mitigate active MITM attacks where an attacker attempts to send fake responses to/from the server or 
							impersonate the server.
						</li>
						<li>
							Mitigate replay attacks and reject any request/response if the data was modified in transit.
						</li>
						<li>
							Prevent a request to the server being modified by an attacker to perform a different API action.
						</li>
						<li>
							Mitigate quantum computer attacks on the protocol.
						</li>
					</ul>
					
					<h3>Limitations and assumptions</h3>
					<ul>
						<li>
							The server administrator will control the server and be a user of the chat group's operating on that 
							server as well. The server administrator will be a trustworthy person not interested in interfering 
							with his own chat group's communications. If a group of users want to communicate with each other, 
							but the server administrator is not included in that group, then they should set up their own server.
							This rules out the server administrator having the will to interfere with communications.
						</li>
						<li>
							Users of the server have an interest in keeping the shared API key on the server a secret to protect 
							their own communications so they will not give that key to anyone else.
						</li>
						<li>
							There is no need for each user having a separate API key on the server to send/receive requests 
							because the server administrator could access that key anyway and impersonate them or simply edit 
							the database record to alter which user the message came from.
						</li>
						<li>
							There is trust between the users in the group communicating not to impersonate other users in the 
							chat group. Because every user in a group has access to all the same one-time pads and same API key, 
							it would technically be possible to pretend to be one of the other users in the chat group. This also 
							doubles as a <a href="https://en.wikipedia.org/wiki/Deniable_authentication">deniable authentication</a> 
							protocol because every message sent could have been engineered to come from one of the other users in 
							the chat group.
						</li>
						<li>
							Encryption for the server protocol is not required because individual messages are encrypted using the 
							one-time pads and signed on each client machine. Some anonymised, non-critical meta-data is viewable 
							if an attacker in a privileged network position is passively watching the traffic. This may indicate 
							a chat conversation is taking place using this protocol. If this is a problem, the user can easily 
							add TLS to the connection and use a pinned certificate. Version 2.0 of the program will encrypt the connection 
							between the client and the server using a cascade stream cipher to hide the meta data and to avoid 
							relying on TLS. Hiding the meta data by sending only encrypted binary blobs between the client 
							and server will make traffic analysis and fingerprinting much more difficult for spy tools like 
                            <a href="https://theintercept.com/2015/07/01/nsas-google-worlds-private-communications/">XKeyScore</a>. 
                            This means <a href="http://www.spiegel.de/international/world/the-nsa-uses-powerful-toolbox-in-effort-to-spy-on-global-networks-a-940969-3.html">TAO agents</a> 
                            will not know whether a client machine is running this program 
							or any other program sending binary data. This lowers the likelihood of them being able to 
							target the client machines with a specific exploit for this program to extract the one-time pads or tamper 
							with them.
						</li>
						<li>
							The server protocol does not anonymise IP addresses from users connecting to the server. If there is a 
							requirement for anonymity, then users can tunnel their connection through a SOCKS5 proxy in 
							their web browser or use <a href="https://www.torproject.org/projects/vidalia.html.en">Vidalia</a> 
							to tunnel their connection through the Tor network.
						</li>
					</ul>
					
					<h3>Initial setup</h3>
					<ul class="formulas">
						<li>
							A random 512 bit <i>API Key</i> is created using the TRNG included with the program and entered 
							into the configuration file on the server. The user can use SSH to access their VPS, but ideally to 
							get the key securely onto the server, the server could be hosted on their local network running a web 
							server with a static public IP that is serving to the wider internet. Storing the key in 
							the configuration file prevents SQL injection attacks to retrieve the key and also it saves a 
							database lookup each request.
						</li>
						<li>
							The <i>API Key</i> is given to each user in person (not using a key exchange protocol or sent 
							via an insecure network). This will be done in the initial key exchange between users as the program 
							can store the <i>API Key</i> and server address along with the one-time pads.
						</li>
						<li>
							The protocol caters for 2-7 users per group using the server. If additional chat groups are required 
							on the same server this can also be setup.
						</li>
					</ul>
					<h3>To send and verify an API request</h3>
					<ul class="formulas">
						<li>
							User creates a random 512 bit per request <i>Nonce</i>. The server keeps track of sent nonces 
							to prevent replay attacks. The nonce is created using the 
							<a href="https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html">Web Crypto API</a>  
							<a href="https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#RandomSource-method-getRandomValues">getRandomValues()</a> 
							method.
						</li>
						<li>
							User creates an API request including a group of data variables to send to the server as part of the 
							<i>Message Packet</i>. For example, this can contain the one-time pad encrypted message 
							and its MAC that the server will store.
						</li>
						<li>
							Each request is sent with an <i>API Action</i> to perform on the server. This prevents the attacker 
							from changing what action to perform on the server because any change to the data packet will alter 
							the MAC.
						</li>
						<li>
							The <i>From User</i> data indicates which user the message is from. The server uses this to retrieve 
							the correct key. All users on the server are coded to 
							<a href="https://en.wikipedia.org/wiki/NATO_phonetic_alphabet">NATO phonetic alphabet</a> names i.e. 
							Alpha, Bravo, Charlie, Delta, Echo, Foxtrot and Golf. This allows some anonymity when multiple servers 
							around the world are using the same protocol. When exporting the one-time pads, the user can assign call 
							signs/nicknames to the chat users within the group to override the default names. These nicknames are 
							not transmitted to the server because they are kept in the user's local storage next to the one-time 
							pads.
						</li>
						<li>
							A <i>Sent Timestamp</i> is included to indicate when the request was sent. This is a 
							<a href="https://en.wikipedia.org/wiki/Unix_time">UNIX timestamp</a> therefore both the client and 
							server code use UTC time.
						</li>						
						<li>
							The server rejects messages received that are received more than +/- 60 seconds of the 
							received UNIX timestamp. The server and clients should be synchronized to an NTP server. The 
							60 second allowance should be enough to counter any clock drift and subtle differences 
							between the server and client clocks.
						</li>
						<li>
							The server rejects duplicate messages/replay attacks received within the allowed time window 
							by storing all received nonces and checking incoming message timestamps against past received 
							nonces. If the nonce is the same and same request is received twice, then the second request 
							will be invalid. Sent nonces are kept on the server for at least 120 seconds and then 
							discarded by a separate cleanup process.
						</li>
						<li>
							These variables are stringified into JSON and a MAC is calculated using version 1.3 of the 
							<a href="https://en.wikipedia.org/wiki/Skein_%28hash_function%29">Skein 512 bit hash function</a> on 
							the JSON data:<br>
							<br>
							<i>MAC</i> = <i>Skein-512</i>( <i>API Key</i> || <i>API Action</i> || <i>From User</i> || <i>Nonce</i> || <i>Sent Timestamp</i> || <i>Message Packet</i> )
						</li>
						<li>
							The client sends the JSON data and the MAC to the server. The server receives the request, looks up 
							the username and verifies it is a valid user for that chat group, then verifies the request by 
							recreating the same MAC with the data provided.
						</li>
						<li>
							The server rejects invalid MACs, which will also mean any attempt to modify the data sent will fail. 
							The MAC validation method in the API is protected against timing side channel attacks using a similar 
                            method to <a href="https://www.isecpartners.com/blog/2011/february/double-hmac-verification.aspx">Double HMAC Verification</a>. 
                            It uses a single hash with the <i>API Key</i> and the <i>Skein-512</i> hash 
                            function rather than using HMAC.
						</li>
						<li>
							Failed requests can be re-sent manually by the client which will use a different <i>Nonce</i>, 
							<i>Sent Timestamp</i> and <i>MAC</i>.
						</li>
						<li>
                            Version 1.5 also <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> encodes the 
                            entire packet before sending in preparation for 
							version 2.0. In version 2.0 the packet will also be encrypted between the client and server 
							and then Base64 encoded. The data going back and forth will essentially just be a random 
                            binary blob. This will help disguise meta data and make it much harder for spy agencies to 
							fingerprint the traffic as definitely originating from this program and prevent them 
                            targeting the client machines or server with automated 
                            <a href="http://www.spiegel.de/international/world/the-nsa-uses-powerful-toolbox-in-effort-to-spy-on-global-networks-a-940969-3.html">TAO hacking tools</a> or malware 
							that has been mentioned in the Snowden revelations. The current version 1.5 will just 
							provide an extra annoyance to the Five Eyes agencies who will need to update their 
                            <a href="https://theintercept.com/2015/07/01/nsas-google-worlds-private-communications/">XKeyScore</a> 
							detection rules and decode the Base64 data first in order to analyse it.
						</li>
					</ul>
					<h3>Server API response</h3>
					<ul class="formulas">
						<li>
							On any valid server requests, the server signs the response with the <i>API Key</i> so that 
							the user knows the response from the real server. Invalid requests throw an 
							<code>HTTP/1.1 404 Not Found</code> error. This means an attacker does not even know if 
							there is a valid application or web page on the web server if they do not have the 
							<i>API Key</i> to make a valid request. All invalid requests respond with the server 
							pretending it is unable to find what the attacker is looking for. This is similar to 
							standard firewall behaviour by just failing to respond at all when an attacker is scanning 
							for open ports on your machine, rather than responding with a distinct 'closed' response 
							which indicates there is something there.
						</li>
						<li>
							The <i>Server Message Packet</i> contains data sent from the server including status responses 
							and the one-time pad encrypted messages.
						</li>
						<li>
							The original <i>Client Request MAC</i> is included in the server's response MAC calculation 
							so the client can be sure it is receiving a response to the original request.
						</li>
						<li>
							The <i>Server Message Packet</i> is stringified into JSON and a MAC is calculated using the
							<a href="https://en.wikipedia.org/wiki/Skein_%28hash_function%29">Skein 512 bit hash function</a> on 
							the JSON data:<br>
							<br>
							<i>MAC</i> = <i>Skein-512</i>( <i>API Key</i> || <i>Server Message Packet</i> || <i>Client Request MAC</i> )
						</li>
						<li>
							If the MAC does not match on the client then the response is not actually from the server and will be 
							discarded. A warning will be shown to the user that interference has occurred.
						</li>
						<li>
							On a successful request and response the client will process the data received from the server, 
							decrypt any received messages, check for XSS attacks and render the messages on the client. 
						</li>
					</ul>
					
					
					<h2 id="using-tls">Using Transport Layer Security (TLS) / HTTPS</h2>
					<p>
						Because of the new server authentication protocol in version 1.3, using TLS is not mandatory anymore. 
						However it can be added as an optional layer of security to help mitigate monitoring from 
						lower level attackers, for example when using the program at work, public WiFi or home connection 
						where your employer, a casual hacker or your ISP could monitor your connection. 
						<a href="http://www.thoughtcrime.org/blog/ssl-and-the-future-of-authenticity/">TLS will not stop a powerful attacker</a> 
						like the NSA or GCHQ as it is possible they have obtained copies of the root keys for most Certificate 
						Authorities anyway by using 
						<a href="https://en.wikipedia.org/wiki/National_security_letter">National Security Letters</a>, therefore 
						they can perform an active <a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">MITM</a> 
						attack as traffic is passing through the <a href="https://en.wikipedia.org/wiki/Five_Eyes">Five Eyes</a> 
						alliance countries (USA, UK, Canada, Australia and NZ). It is also possible 
						<a href="http://www.washingtonpost.com/world/national-security/nsa-seeks-to-build-quantum-computer-that-could-crack-most-types-of-encryption/2014/01/02/8fff297e-7195-11e3-8def-a33011492df2_story.html">they have quantum computers</a> 
						by now. The public key exchange protocols used in TLS are vulnerable to quantum computers, as are most of 
						the common cipher suites which use symmetric keys of 
						only 128 bits. Key lengths of 
						<a href="https://en.wikipedia.org/wiki/Grover%27s_algorithm">256 bits are the minimum required</a> to 
						remain safe against quantum computers in the immediate future. Care must also be taken to use a good 
						cipher suite order to have forward secrecy and use the highest quality ciphers available.
					</p>
					<p>						
						Users still wanting to use TLS and don't mind the extra effort to configure it are recommendeded to 
						<a href="installation-server.html#install-tls-certificate">generate a strong</a> (4096+ bit) self-signed 
						certificate themselves, install it on the server and deliver the fingerprints of the certificate to 
						the chat group users at the same time as the one-time pad key exchange which they can manually 
						verify when first connecting to the server.
					</p>
					
					
					<h2 id="frustrating-traffic-analysis">Preventing information leakage and traffic analysis</h2>
					<p>
						In version 1.5, each client now sends decoy messages at random intervals to other users in 
						the chat group to prevent 
						<a href="https://en.wikipedia.org/wiki/Information_Leakage">information leakage</a> (e.g. when 
						real messages are sent) and to frustrate 
						<a href="https://en.wikipedia.org/wiki/Traffic_analysis">traffic analysis</a>. This technique 
						is similar in principle to the 
						<a href="https://en.wikipedia.org/wiki/Chaffing_and_Winnowing">Chaffing and Winnowing</a> 
						cryptographic technique. On starting a 
						chat session, each client will generate a random number between 1000 and 90,000 using the 
                        <a href="https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html">browser's CSPRNG</a>. 
                        A timer will be started and after this number of milliseconds have 
						elapsed the program will generate a random string of bytes up to 56 bits bits in length. Using 
						the accuracy of milliseconds rather than seconds gives more randomness for each timer interval. 
						Otherwise every decoy message would be sent on evenly rounded seconds and an attacker could 
						determine that they were decoy messages.
					</p>
					<p>						
						The program will then check if these 56 bits exist as a pad identifier in their own set of 
						one-time pads. If that pad identifier already exists, which is quite rare (1 in 2<sup>56</sup> 
						chance), then it will skip sending a decoy message for this interval, generate a new random 
						number and try again after that many seconds have elapsed. If the pad identifier does not already 
						exist, then the program will send a decoy message to the other users in the chat group. The other 
						chat group users will safely ignore the decoy message as the pad identifier does not exist in 
						their copy of the one-time pad database for the user that is sending the message. To send a 
						decoy message the program simply generates a further random 1480 bits using the 
                        <a href="https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html">browser's CSPRNG</a> 
						and concatenates that to the end of the 56 bit random pad identifier, thus forming a random 
						string consisting of 1536 bits which is the same size as a regular one-time pad and message packet. 
						This method also avoids burning real one-time pads on decoy messages which would be wasteful.
					</p>
					<p>
						The random message packet is sent as is to the server and left on there for the other chat group 
						users to collect. It effectively looks no different than a regular message being sent. The other 
						chat group users will download it, determine it is not a real message because the pad identifier 
						does not exist in the set of pads belonging to that user and discard it. The other users may not 
						be saying anything but each client that is connected to the server will be sending decoy messages 
						to other users in the group at random intervals. If two or more clients are just left unnattended 
						it can look like an entire conversation is taking place without doing anything. This disguises 
						when real messages are actually sent by the users. An outside attacker that can monitor all 
						network traffic has no way of determining whether a message sent or received is a decoy or a real 
						one. 
					</p>
					<p>
						If a client is online but there have been no real or decoy messages received from other chat 
						clients for 3 minutes then the decoy timer will stop. This is so it doesn't appear like one user 
						is just	talking to themself. If another client comes online again and sends a real message or 
						decoy message then the first client will start up their timer again on a random interval to keep 
						sending decoy messages. This continues until a user quits the program or all other users are 
						offline for over 3 minutes. This is twice the length of the maximum random timer interval 
						(90 seconds) so there is some overlap when users are coming online/offline. These intervals 
						may be customisable via the UI in future versions or further optimised for network bandwidth 
						usage.
					</p>
					<p>
						An added bonus of this functionality is that if a user has come online and received a new decoy 
						message from another user they can know that the other user is most likely online (+/- 90 seconds) 
						without any other kind of signalling protocol being needed. The program will also show that the 
						other user is online immediately if a real message is received within the last 90 seconds as well.
					</p>
										
					
					<h2 id="trng-photo">True Random Number Generator (TRNG)</h2>
					<p>
						Nature is random, unpredictable and always changing. For example, the sand on the 
						seashore changes every time the tide rolls in. Wave crests and currents change with the weather and tides. 
						Deciduous trees change depending on the season of the year. Trees and leaves move in the wind. The sun 
						strikes things in different angles and intensity throughout the day, casting shadows in various directions. 
						The variance of cloud cover and light conditions alters the appearance of everything in different ways.
					</p>
					<p>
						This section describes the True Random Number Generator (TRNG) included with the program which gathers 
						the entropy contained in the <a href="https://en.wikipedia.org/wiki/Shot_noise">shot noise</a> of a high 
						resolution photograph from a digital camera to obtain truly random data, then it runs a randomness extractor 
						on the data to ensure a uniform distribution. The shot noise contains random data because the act of capturing 
						something, converting it from analog to digital, and storing it in 24 bit values creates randomness due 
						to the fact that the process creates noise on the 
						<a href="https://en.wikipedia.org/wiki/Least_significant_bit">least significant bits</a>. 
						Randomness tests are run on the random data after the randomness extractor has run to 
						verify the quality.
					</p>
					<p>
						From a photographer's position they have a unique viewpoint of a scene in nature. They can take a photo of 
						anything in nature, giving an infinite number of possible photographs. The proposed method is to take a 
						photograph of something that is random in nature such as a 
						<a href="https://en.wikipedia.org/wiki/Macro_photography">macro</a> (close-up) shot of sand on a beach, 
						grass, rocks, trees blowing in the wind, wave crests in the ocean, or waves crashing against the sea shore. 
						The photo should be taken with high resolution and in focus using a standalone digital camera. 
					</p>
					<p>
						The best results are obtained capturing the photograph using a digital camera's 
						<a href="https://en.wikipedia.org/wiki/Raw_image_format">RAW mode</a> then converting the RAW image file  
						as-shot (without post-processing) to a lossless format like 
						<a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics">PNG</a>/<a href="https://en.wikipedia.org/wiki/BMP_file_format">BMP</a> 
						for the TRNG program to process. 
						Saving in a lossy algorithm like <a href="https://en.wikipedia.org/wiki/Jpeg">JPEG</a> may have unintended 
						side effects from performing optimisations on the photograph. Modern digital cameras in cellular phones may not 
						be suitable as they usually compress the photo using JPEG. Users can however verify the processed results 
						and check if the random data passes the required randomness tests.
					</p>
					
					

					<h3 id="photo-processing-algorithm">TRNG photo processing algorithm</h3>
					<p>
						This process describes the full algorithm:
					</p>
					<ol>
						<li>
							Load the user's photograph into memory and store it in a sequential array of RGB values.
						</li>
						<li>
							Get the red, green and blue (RGB) integer values for each pixel. This will return a number 
							between 0 and 255 for each colour.
						</li>
						<li>
							Remove sequentially repeating black (0, 0, 0) pixels, white (255, 255, 255) pixels 
							and pixel colours that are exactly the same. This removes sections of the photograph with 
							underexposed pixels, overexposed pixels and those that have have little entropy. Generally 
							it is very unusual to have adjacent pixels that are exactly the same colour unless there is 
							a hardware failure, or the section of the photo is under/overexposed. Usually in a good quality 
							photograph there are at least very slight colour variations in adjact pixels. This step 
							removes these low entropy areas.
						</li>
						<li>
							Estimate 1 bit of input entropy per set of RGB values (1 bit per 24 bit pixel). This is a very 
							conservative estimate. Users can increase this in the TRNG settings to 3 bits per pixel which 
							would account for the entropy in the 
							<a href="https://en.wikipedia.org/wiki/Least_significant_bit">least significant bit</a> of 
							each colour.
						</li>
						<li>
							Gather 512 RGB values to get an estimated entropy input of 512 bits.
						</li>
						<li>
							Convert the 512 RGB values to their hexadecimal representation and input them into a 
							cryptographic hash with a 512 bit output. The user can choose which hash to use and the program 
							allows either <a href="https://en.wikipedia.org/wiki/Skein_(hash_function)">Skein</a> or 
							<a href="https://en.wikipedia.org/wiki/SHA-3">Keccak</a> [c=2d]. Both are very strong finalist 
							algorithms from the <a href="https://en.wikipedia.org/wiki/NIST_hash_function_competition">NIST hash function competition</a>. 
							Store this hash output of 512 bits as the temporary seed into the next hash.
						</li>						
						<li>Start a <a href="https://en.wikipedia.org/wiki/While_loop">loop</a>:
							<ol class="roman">								
								<li>
									Check there is enough new input entropy for the new hash, or break out of the loop.
								</li>
								<li>
									Get the temporary seed from earlier.
								</li>
								<li>
									Get a new set of 512 RGB values (512 bits) as the new input entropy.
								</li>								
								<li>
									Concatenate the seed and input entropy together and hash them using: 
									<span class="formulas"><i>Hash</i>( <i>seed</i> || <i>input entropy</i> )</span>.
								</li>
								<li>
									Append the first 256 bits of the hash output to the output random data.
								</li>								
								<li>
									Update the temporary seed to be the last 256 bits of the hash output.
								</li>
								<li>
									Return to start of the loop.
								</li>
							</ol>
						</li>						
					</ol>
					<p>
						It is important to note that the program does not use this collected entropy to seed a   
						<a href="http://en.wikipedia.org/wiki/Pseudo-random_number_generator">psuedo-random number generator</a> 
						to give an unlimited amount of random data. The program aims to be a true random number generator so 
						only quality randomness is wanted and each uniformly random bit must be used solely to encrypt one 
						bit of the plaintext. It's assumed that most psuedo-random number generators or even 
						<a href="http://en.wikipedia.org/wiki/CSPRNG">CSPRNGs</a> that stretch out the entropy could produce 
						a subtle bias in the output and allow the NSA or other governments to decrypt part or all of a message. 
						With this program the aim is to avoid stretching the available entropy over more bits.
					</p>
										
					
					<h3 id="output-testing">Testing the TRNG random output</h3>
					<p>
						An important part of a random number generator is the ability to test the output. A few methods have been 
						provided for this:
					</p>
					<ul>
						<li>
							Extracting the random data in various formats (binary file, hexadecimal & Base64) gives users 
							the opportunity to verify the data with another randomness testing program. That will allow them to 
							run additional tests and assure them of the quality of the random data.
						</li>
						<li>
							For testing the random data there are some statistical random number generator tests included from 
							<a href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">FIPS 140-2</a>. These 
							include: The Monobit Test, The Poker Test, The Runs Test and The Long Run Test. The goal is to add 
							more automated tests in the future to prove the quality of the program and improve on it in future 
							versions of the software. The FIPS 140-2 test suite is run on every 20,000 bits in the extracted 
							random data. If any of the tests fail after this, then the original source photograph was 
							definitely not good enough and another one will need to be used.
						</li>
						<li>
							The output of the TRNG can also be viewed as a <a href="http://en.wikipedia.org/wiki/Bitmap">bitmap</a> 
							image which lets a user do a simple visual analysis of the output. 
							<a href="http://www.random.org/analysis/">Random.org explains</a> that people are really good at 
							spotting patterns and visualising the random data allows them to use their eyes and brain for this 
							purpose. It also gives a rough impression of the TRNG's performance.<br>
							<br>
							To produce this, all the random data is converted to binary and rendered as a bitmap. A black pixel 
							indicates a '1' bit and white pixel indicates a '0' bit. The output should look something like the 
							image below at 100% zoom.
						</li>
					</ul>
					<p class="diagram">
						<img src="img/random-bitmap-example.png" alt="Random bitmap example">
					</p>
					
										
					<h2 id="trng-test-analysis">TRNG tests and analysis</h2>
					<p>
						For our testing we used a 12 MP <a href="https://en.wikipedia.org/wiki/Canon_G9#G7_to_G12">Canon G9</a> 
						digital camera. This camera is a high-end compact digital camera and allows taking photographs in 
						<a href="https://en.wikipedia.org/wiki/Raw_image_format">RAW file format</a>. 
						Photos were taken in manual mode using the RAW file format. The photos were then loaded into Photoshop, 
						converted as is to PNG which avoided using the camera's default lossy JPEG file format. 
						Then tests were run by taking photographs of various places and things, processing the photos 
						with the TRNG and running the test suite on everything. The results are presented below.
					</p>
					<p>
						<i>
							The original camera images were 4000 x 3000 pixels, then have been cropped to 1000 x 750 pixels 
							for faster processing and to save bandwidth. The photos were processed with the Skein 512 bit hash 
							algorithm and an estimate of 1 bit per pixel entropy input. Click on the thumbnail images 
							below to see a bigger image.
						</i>
					</p>
					
					
					<h3>Macro shot of sand at a beach</h3>
					<p>
						This is an example of the TRNG output from processing a macro shot of sand at a beach. See the full test 
						results output <a href="img/randomness-tests/sand-test-results.txt">here</a> as a text file. This passes 
						all the randomness tests and is one of the best photograph sources.
					</p>
					<div class="testOutput">
						<h4>Original photo</h4>
						<a href="img/randomness-tests/sand-original-photo.png">
							<img class="nonPrintable" src="img/randomness-tests/sand-original-photo-preview.png" alt="Sand">
							<img class="printable" src="img/randomness-tests/sand-original-photo.png" alt="Sand">
						</a>						
					</div>					
					<div class="testOutput">
						<h4>Extracted entropy</h4>
						<a href="img/randomness-tests/sand-extracted-entropy.png">
							<img class="nonPrintable" src="img/randomness-tests/sand-extracted-entropy-preview.png" alt="Sand">
							<img class="printable" src="img/randomness-tests/sand-extracted-entropy.png" alt="Sand">
						</a>
						<div class="results">Extracted entropy FIPS 140-2 tests: <span class="pass">Pass</span></div>
					</div>
					
					
					<h3>Macro shot of grass</h3>
					<p>
						This is an example of the TRNG output from processing a macro shot of grass in a field. See the full test 
						results output <a href="img/randomness-tests/grass-test-results.txt">here</a> as a text file. This passes 
						all the randomness tests and is one of the best photograph sources.
					</p>
					<div class="testOutput">
						<h4>Original photo</h4>
						<a href="img/randomness-tests/grass-original-photo.png">
							<img class="nonPrintable" src="img/randomness-tests/grass-original-photo-preview.png" alt="Grass">
							<img class="printable" src="img/randomness-tests/grass-original-photo.png" alt="Grass">
						</a>						
					</div>
					<div class="testOutput">
						<h4>Extracted entropy</h4>
						<a href="img/randomness-tests/grass-extracted-entropy.png">
							<img class="nonPrintable" src="img/randomness-tests/grass-extracted-entropy-preview.png" alt="Grass">
							<img class="printable" src="img/randomness-tests/grass-extracted-entropy.png" alt="Grass">
						</a>
						<div class="results">Extracted entropy FIPS 140-2 tests: <span class="pass">Pass</span></div>
					</div>
					
					
					<h3>Photo of trees</h3>
					<p>
						This is an example of the TRNG output from processing a photo of trees. See the full test 
						results output <a href="img/randomness-tests/trees-test-results.txt">here</a> as a text file. This 
						is not a particularly good photograph due to it being overexposed with some of the bright cloud 
						showing through the trees, thus the overexposed sections will be a single repeated colour. The 
						algorithm will remove these overexposed sections and the extracted output still passes the tests, 
						however there is less usable random data than normal.
					</p>
					<div class="testOutput">
						<h4>Original photo</h4>
						<a href="img/randomness-tests/trees-original-photo.png">
							<img class="nonPrintable" src="img/randomness-tests/trees-original-photo-preview.png" alt="Trees">
							<img class="printable" src="img/randomness-tests/trees-original-photo.png" alt="Trees">
						</a>						
					</div>
					<div class="testOutput">
						<h4>Extracted entropy</h4>
						<a href="img/randomness-tests/trees-extracted-entropy.png">
							<img class="nonPrintable" src="img/randomness-tests/trees-extracted-entropy-preview.png" alt="Trees">
							<img class="printable" src="img/randomness-tests/trees-extracted-entropy.png" alt="Trees">
						</a>
						<div class="results">Extracted entropy FIPS 140-2 tests: <span class="pass">Pass</span></div>
					</div>
					
					
					<h3>Photo of water</h3>
					<p>
						This is an example of the TRNG output from processing a photo of water in a harbour. See the full test 
						results output <a href="img/randomness-tests/water-test-results.txt">here</a> as a text file.
					</p>
					<div class="testOutput">
						<h4>Original photo</h4>
						<a href="img/randomness-tests/water-original-photo.png">
							<img class="nonPrintable" src="img/randomness-tests/water-original-photo-preview.png" alt="water">
							<img class="printable" src="img/randomness-tests/water-original-photo.png" alt="water">
						</a>						
					</div>					
					<div class="testOutput">
						<h4>Extracted entropy</h4>
						<a href="img/randomness-tests/water-extracted-entropy.png">
							<img class="nonPrintable" src="img/randomness-tests/water-extracted-entropy-preview.png" alt="water">
							<img class="printable" src="img/randomness-tests/water-extracted-entropy.png" alt="water">
						</a>
						<div class="results">Extracted entropy FIPS 140-2 tests: <span class="pass">Pass</span></div>
					</div>
					
					
					<h3>Photo of clouds</h3>
					<p>
						This is an example of the TRNG output from processing a photo of clouds. See the full test 
						results output <a href="img/randomness-tests/clouds-test-results.txt">here</a> as a text file. Clouds are 
						generally not a good source photograph as there are a lot of repeating colours. These do get stripped out 
						with the algorithm, but in the end you are left with less random data. The extracted output will 
						still pass the FIPS 140-2 tests, however it may be wiser to use another source image.
					</p>
					<div class="testOutput">
						<h4>Original photo</h4>
						<a href="img/randomness-tests/clouds-original-photo.png">
							<img class="nonPrintable" src="img/randomness-tests/clouds-original-photo-preview.png" alt="clouds">
							<img class="printable" src="img/randomness-tests/clouds-original-photo.png" alt="clouds">
						</a>						
					</div>
					<div class="testOutput">
						<h4>Extracted entropy</h4>
						<a href="img/randomness-tests/clouds-extracted-entropy.png">
							<img class="nonPrintable" src="img/randomness-tests/clouds-extracted-entropy-preview.png" alt="clouds">
							<img class="printable" src="img/randomness-tests/clouds-extracted-entropy.png" alt="clouds">
						</a>
						<div class="results">Extracted entropy FIPS 140-2 tests: <span class="pass">Pass</span></div>
					</div>
					
					
					<h3>Summary</h3>
					<p>
						In summary, the best results are achieved using the macro mode on a digital camera and taking close-up 
						shots of things like sand or grass. Shooting a variety of things like rocks, trees or water can also 
						work. Users can experiment taking photos of various things in nature on their own. Users should take 
						care to verify the extracted random data passes the FIPS 140-2 tests. This will give full 
						confidence for using it as one-time pads. With this TRNG and a single 12 MP photo, it can produce 
						enough random data for approximately 3900 messages (depending on the source photograph quality).
					</p>
					<p>
						The safest method is to use a photo from a standalone digital camera that has been captured in 
						the camera's raw image format, transferred to a computer by USB cable (or SD card), then 
						losslessly converted to PNG (or BMP) file format. Avoid using a mobile phone as they generally 
						have poor security and the contents can be secretly collected from them at any time due to the 
						<a href="http://en.miui.com/thread-10712-1-1.html">closed baseband processor</a>. The user should 
						erase the original photo after the one-time pads have been created from it. To be extra safe, users 
						should run the TRNG program from a non-networked 
						(<a href="http://en.wikipedia.org/wiki/Air_gap_%28networking%29">air gapped</a>) computer.
					</p>
					
					
					<h2 id="trng-custom">Custom random data loading</h2>
					<p>
						In the version 1.4 release onwards, the software allows users to import random data directly from 
						their own trusted sources e.g. a hardware RNG or physical entropy source to use with the program. 
						This will allow for creating a lot more one-time pads in a shorter period of time.
					</p>
					<p>
						Users can change the upload type of the file from plain binary, to a plain text file containing hexadecimal 
						symbols or Base64 characters. Once uploaded, the FIPS 140-2 tests will be run on the random data 
						to prove that the random data is good quality. If the tests pass the user can export the random data 
						and the program will split up the random data into separate one-time pads for use with the program.
					</p>
					
															
					<h2 id="pad-storage-export">Pad storage and exporting data</h2>
					<p>
						After the one-time pads have been created, they must be exported separately for each user. Part of this 
						process automatically determines who will be sending with what one-time pads. The one-time pads are divided 
						up equally amongst the group members and allocated to each user for sending. This prevents one user from 
						accidentally sending with another user's allocated one-time pads, causing a two-time pad situation and 
						allowing for cryptanalysis. All users get read access to the other group member's one-time pads, so when 
						a message is received from another user they can decrypt it.
					</p>
					<p class="diagram">
						<img alt="Export settings" src="img/export-pads-settings.png">
					</p>
					<ul>
						<li>
							This screen contains all the details that will be saved to each export file for each chat group user. 
							The person creating the chat group should input the server address and API key here so that when other 
							users import the file they do not need to do any additional configuration. All they need to do 
							then is load the one-time pads into their browser and start chatting. 
						</li>
						<li>
							A server API key can be generated from this screen. The program effectively takes 512 bits from the 
							start of the extracted random data and uses it as the key. This 512 bits is now no longer available 
							for use as a one-time pad. This API key is manually loaded up into the server's config file by the user. 
							After this the user can test the connection to the server to make sure everything is set up correctly.
						</li>
						<li>
							The user can also define how many users will be in the chat group. They can customise the user's name 
							or nickname next to the call sign. The custom nickname is kept locally and stored with the one-time pads. 
							This way each chat group user has the same set of names and knows who is in the conversation. The custom 
							nickname is not sent over the network, only the call sign (alpha, bravo etc) is sent as part of each 
							network request so the server can send/receive messages for that user. This means only the real users 
							know who is talking to who. If there are multiple people and chat groups around the world using the 
							same protocol and different servers, then it makes traffic analysis even more difficult.
						</li>
						<li>
							There are 3 export options for using the one-time pads with the program. <b>Export to clipboard</b> 
							lets you copy/paste the pads from memory into wherever you want to put them. <b>Export to text file</b> 
							pops up a save dialog to save the pads to a text file on your filesystem or portable storage media. 
							Exporting to the <b>browser's local database</b> is if you want to export the created pads for that 
							user into the local storage of that device/computer browser directly and start chatting immediately.
						</li>
						<li>
							Saving to removable media such as a CD, DVD, MicroSD, SD card or USB drive will be convenient and 
							portable. Flash memory is at least small and compact which means you can conceal, destroy or 
							get rid of it quickly and easily. The most secure option may be to use CDs/DVDs which can be 
							written once, transferred to each user, then destroyed. The most convenient option is to get 
							a USB thumbdrive, with a portable version of 
							<a href="http://portableapps.com/apps/internet/firefox_portable">Firefox</a> loaded on it. 
							Save the one-time pads in there as well. Load up Firefox and then load the one-time pads from 
							inside it. Now the program is portable and you can take it with you on your keyring, run it 
							from any trusted computer (e.g. home or work) and stay in contact wherever you are.
						</li>
						<li>
							<a href="http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html">Hard drives and flash 
							memory are notoriously difficult</a> to remove data from. Version 1.5 of the program now allows 
							for the one-time pad database to be encrypted and authenticated before transport. This is 
							detailed in full in the next section.
						</li>
						<li class="formulas">
							The password/passphrase used should have at least 256 bits of entropy for transport which is 
							about 41 characters. In version 2.0 the database will be encrypted all the time so users may 
							opt for a shorter password for faster access on their mobile devices.
							The password strength estimator calculates a rough estimate of the password strength in bits 
							as the user is typing. Password characters are assumed to be drawn uniformly randomly among the 
							most commonly used characters on a standard US keyboard. This is calculated as uppercase A-Z 
							(26 characters) plus lowercase a-z (26 characters) plus numbers 0-9 (10 characters) for a 
							total of 62 characters. This will produce a more conservative entropy estimate than if special 
							characters were included as well (i.e. the full 95 ASCII printable characters). The formula 
							will also take into account the PBKDF iterations which roughly increases the security in bits 
							by <i>log<sub>2</sub></i>( <i>Iterations</i> ) e.g. <i>log<sub>2</sub></i>( <i>10,000</i> ) 
							which is approximately 13~ bits. The full formula for calculating the entropy of the password 
							in bits is as follows:<br>
							<br>
							<b>Entropy Bits</b> = ( <i>Number of Password Characters</i> &#215; <i>log<sub>2</sub></i>( <i>62</i> )) + <i>log<sub>2</sub></i>( <i>Number of PBKDF Iterations</i> ).							
						</li>
					</ul>
					
					
					<h2 id="database-encryption">One-time pad database encryption and authentication</h2>
					<p>
						Since version 1.5, the program can now encrypt and authenticate the one-time pad 
						database prior to export and transportation to other chat group users. The program uses a 
						strong cascade stream cipher encryption and a cascade of two modern MAC algorithms for 
						authentication. This provides additional assurances such as:
					</p>
					<ul>
						<li>
							The database has not been tampered with in transit. An attacker cannot replace the 
							one-time pads with ones that they already know which would allow covert surveillance, set 
							all the one-time pads to zero bits which would nullify the encryption, subtly duplicate the 
							one-time pads in the database which would allow for two-time pad cryptanalysis, or swap pads 
							between users which would cause lost/indecipherable messages for other users in the group.
						</li>
						<li>
							The database is not easily readable if stolen or seized in transit. A computationally unbounded 
							adversary could in theory break the cascade encryption after many decades of brute force 
							attack with a quantum computer, but this is very unlikely. If a user knew that their 
							one-time pad database was stolen or seized (e.g. at an international airport) then they 
							would notify the other chat group users to stop using that set of one-time pads immediately 
							and switch to a different set. Then only the small number of messages which had been sent 
							since one-time pad generation until that point in time would be compromised. Because only a 
							small number of messages would have been sent during this time and the database is very 
							difficult to crack, then this reduces the likelyhood an attacker would even try mounting a 
							brute force attack.
						</li>
						<li>
							After successful transportation of the one-time pads without interception or tampering, the 
							database can be quickly deleted and the rewriteable transport media (e.g. MicroSD card, SD 
							card, USB drive) can be re-purposed for something else which would overwrite the database 
							eventually anyway. Because an attacker does not even have the encrypted one-time pad 
							database, it is not absolutely necessary to secure erase the media or destroy it (e.g. 
							write once CD, DVD media) unless absolute security is required.
						</li>
					</ul>
					<p>
						In version 2.0 of the program, which is currently in development, the same encryption will be 
						used to secure the database as it resides on the client devices. Pads will be decrypted as they 
						are needed, used to encrypt a message, then deleted from the database. The program does not currently  
						provide any steganography for transporting the database, so if this is needed in the near future 
                        it is advised to use a 
                        <a href="http://www.howtogeek.com/109210/the-htg-guide-to-hiding-your-data-in-a-truecrypt-hidden-volume/?PageSpeed=noscript">TrueCrypt 7.1a hidden volume</a> 
                        and store the one-time pad database 
						inside it. If an attacker forces you to reveal the password you can reveal the outer volume 
						password which would reveal decoy files, and you would still have plausible deniability that a 
						hidden volume containing the one-time pads does not exist.
					</p>
					
					<h3 id="cascade-database-encryption">Cascade database encryption</h3>
					<p>
						To encrypt each one-time pad in the database a cascade of two strong, reputable stream 
                        ciphers is used. The ciphers are the 
                        <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Advanced Encryption Standard</a> (AES)
                        in <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_.28CTR.29">Counter Mode</a> (AES-CTR) 
                        and <a href="https://en.wikipedia.org/wiki/Salsa20">Salsa20</a> with the full 20 rounds. AES, 
                        which is based on the Rijndael algorithm by Vincent 
                        Rijmen and Joan Daemen, won the 
                        <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard_process">Advanced Encryption Standard competition</a>. 
                        A reduced 12 round variant of Salsa20 (Salsa20/12) by Daniel J. Bernstein was selected for the 
                        <a href="https://en.wikipedia.org/wiki/ESTREAM#In_ESTREAM_portfolio">eSTREAM software portfolio</a>. 
                        The full 20 round variant of Salsa20 was chosen for added security. 
						Two random 256 bit keys are generated using the TRNG at export time. One key is used for AES-CTR 
						and the other for Salsa20. A different nonce is used for each one-time pad to be encrypted in the 
						database. The design Exclusive ORs (XORs) the AES-CTR keystream and the Salsa20 keystream 
						together then XORs the combined keystream with the plaintext one-time pad.
					</p>
					<p>
						The reason a cascade of two stream ciphers is used is because there may be secret cryptanalytic 
						techniques against a cipher such as AES when it's used to encrypt something on its own. A 
                        recent publication of the Snowden documents revealed that 
                        <a href="http://www.spiegel.de/international/germany/bild-1010361-793640.html">NSA have their own in-house (non public) techniques</a> 
                        against AES and other ciphers. 
						While a trivial reversal of a strong cipher without any additional information is highly 
						unlikely and would be indicative of the algorithm being very weak, it may be more likely that a single 
                        encryption algorithm becomes vulnerable to NSA when they have access to 
                        <a href="https://en.wikipedia.org/wiki/Cryptanalysis">known or chosen plaintext</a> 
						encrypted by the algorithm as well. With a stream cipher cascade, the separate 
						keystreams are XORed together. There is no way to determine which bits belong to each keystream 
						and cipher if each cipher is suitably strong on their own. Even if there is a cryptanalytic break in AES, 
						an attacker does not have access to the raw keystream created by the AES algorithm because 
						there is still plaintext and the Salsa20 keystream mixed in with it. Even if an attacker knows 
						a lot of the plaintext they still won't be able to decrypt the AES layer of encryption because 
						the layer underneath is a random Salsa20 keystream which they do not know. Likewise if they 
						tried to decrypt the Salsa20 encryption layer first, the next layer is a random AES keystream 
						so they would not even know when they have decrypted the first layer correctly. The best 
						remaining attack against a stream cipher cascade may be a brute force of both keys which would 
						take a very long time.
					</p>
					<p>
						The following describes the encryption for the database:
					</p>
					<div class="formulas">
						<b>Key<sub>1</sub></b> = A 256 bit random key for AES-CTR generated by the TRNG<br>
						<b>Key<sub>2</sub></b> = A different 256 bit random key for Salsa20 generated by the TRNG<br>
						<b>Nonce<sub>1</sub></b> = A unique 96 bit nonce for AES-CTR, changing for each database row (one-time pad) to be encrypted<br>
						<b>Nonce<sub>2</sub></b> = A unique 64 bit nonce for Salsa20, changing for each database row (one-time pad) to be encrypted<br>
						<b>Counter<sub>1</sub></b> = A 32 bit counter for AES-CTR, starting at 0 for each database row and incrementing by 1 for each block being encrypted<br>
						<b>Counter<sub>2</sub></b> = A 64 bit counter for Salsa20, starting at 0 for each database row and incrementing by 1 for each block being encrypted<br>
						<br>
						<b>Keystream<sub>1</sub></b> = <i>AES-CTR</i>( <i>Key<sub>1</sub></i>, ( <i>Nonce<sub>1</sub></i> || <i>Counter<sub>1</sub></i> ))<br>
						<b>Keystream<sub>2</sub></b> = <i>Salsa20</i>( <i>Key<sub>2</sub></i>, ( <i>Nonce<sub>2</sub></i> || <i>Counter<sub>2</sub></i> ))<br>
						<br>
						<b>Row Cascade Encryption</b> = <i>Keystream<sub>1</sub></i> &oplus; <i>Keystream<sub>2</sub></i> &oplus; <i>One-Time Pad</i><br>
						<b>Row Cascade Decryption</b> = <i>Ciphertext One-Time Pad</i> &oplus; <i>Keystream<sub>2</sub></i> &oplus; <i>Keystream<sub>1</sub></i><br>
					</div>
					<ul>
						<li>
							The reason to encrypt each row individually rather than encrypting the entire database at 
							once is for performance. Also in the upcoming version 2.0 of the program the database will 
							always be encrypted on disk, so it is advantageous to only have the small keys in memory and 
							decrypt each row as needed then delete the row.
						</li>
						<li>
							The keys remain the same for the entire database but the nonce changes for each database row 
							to be encrypted. The keys for encryption and authentication are obtained from slicing the 
							required number of bits off the beginning of the TRNG generated random data. This ensures 
							the keys are not used for anything else and the one-time pads are generated from the 
							remaining random data.
						</li>
						<li>
							Because AES in Counter Mode does not need a random IV, a unique nonce is used for 
							encrypting each row. Each one-time pad has an index number in the database starting from 0 
							up to the number of pads in the database. One user might have index numbers from 0 - 1000 in 
							their set of one-time pads and the next user might have index numbers from 1001 to 2000 in 
							their set. This ensures there is a unique index number for each row in the database. This 
							number is converted to hexadecimal and left padded with 0 bytes (<code>00</code> in hexadecimal) 
							up to 96 bits in length. The block counter for AES is 32 bits in length starting at 0 
							(<code>00000000</code> in hexadecimal) for each row and increments by 1 for each subsequent 
							block being encrypted.
						</li>
						<li>
							The nonce for Salsa20 is 8 bytes, so the pad index number is is converted to hexadecimal 
							and left padded with 0 bytes (<code>00</code> in hexadecimal) up to 64 bits in length. The 
							block counter for Salsa20 is also 8 bytes starting at 0 (<code>0000000000000000</code> in 
							hexadecimal) for each row and increments by 1 for each subsequent block being encrypted.
						</li>
						<li>
							The first 56 bits of a one-time pad is the pad identifier which is public and used to 
							lookup the correct pad in the database when another user sends a message. The pad 
							identifier is not encrypted and removed prior to encryption so only the remaining 1480 bits 
							of the random pad are encrypted. This removes any remaining known plaintext for an attacker 
							if they attempt to decrypt one of the one-time pads.
						</li>
						<li>
							There is some pad database information which is stored in the client database as well 
							(program version, custom user preferences, server address, server key, user callsign and 
							list of group user nicknames). This is JSON encoded to a string and encrypted with the same 
							database keys, but the 96 bit nonce <code>ffffffffffffffffffffffff</code> in hexadecimal 
							for AES-CTR and the 64 bit nonce <code>ffffffffffffffff</code> for Salsa20 is used for 
							encryption. Because each pad index number is converted to a nonce and in the language being 
							used integers cannot exceed 2<sup>53 - 1</sup> (9007199254740991), this nonce cannot be 
							accidentally be re-used for encrypting a pad, therefore it is used it to encrypt the pad 
							database information.
						</li>
					</ul>
					
					<h3 id="cascade-database-authentication">Cascade database authentication</h3>
					<p>
                        Using the safe principles of <a href="https://en.wikipedia.org/wiki/Authenticated_encryption#Encrypt-then-MAC_.28EtM.29">Encrypt Then MAC</a>, 
                        the program creates a MAC of the database row 
						information including the encrypted one-time pad by using a cascade MAC. The chosen hash functions 
                        for this are <a href="https://en.wikipedia.org/wiki/SHA-3">Keccak-512</a> with the capacity set 
                        at 1024 (same as the <a href="https://en.wikipedia.org/wiki/SHA-3#Instances">finalised SHA3</a>) and 
                        <a href="https://en.wikipedia.org/wiki/Skein_%28hash_function%29">Skein-512</a>. Each MAC digest 
                        is calculated independently by computing 
						<span class="formulas"><i>Hash</i>(<i>Key</i> || <i>Data</i>)</span> with independent keys for 
						each algorithm. The resulting digests are then XORed together to hide the individual MAC digests 
						from independent cryptanalysis in case one of the algorithms has a flaw. Keccak and Skein are 
						newer hash functions that are not vulnerable to length extension attacks with this simple MAC 
						construct.
					</p>
					<p>
						The following describes the authentication for each row in the database:
					</p>
					<div class="formulas">
						<b>MAC Key<sub>1</sub></b> = A 512 bit random key for Keccak-512 generated by the TRNG<br>
						<b>MAC Key<sub>2</sub></b> = A different 512 bit random key for Skein-512 generated by the TRNG<br>
						<b>Nonce<sub>1</sub></b> = A unique 96 bit nonce based on the row index number which was used by AES-CTR to encrypt the one-time pad<br>
						<b>Nonce<sub>2</sub></b> = A unique 64 bit nonce based on the row index number which was used by Salsa20 to encrypt the one-time pad<br>
						<b>User Callsign</b> = The user callsign (e.g. 'alpha', 'bravo', 'charlie' etc) which this one-time pad is allocated to for sending<br>
						<b>Pad Identifier</b> = The first 56 bits of the one-time pad<br>
						<b>Ciphertext One-Time Pad</b> = The remaining 1480 bits of the one-time pad which is encrypted by AES-CTR and Salsa20<br>
						<br>
						<b>MAC<sub>1</sub></b> = Keccak-512( <i>MAC Key<sub>1</sub></i> || <i>Nonce<sub>1</sub></i> || <i>Nonce<sub>2</sub></i> || <i>User Callsign</i> || <i>Pad Identifier</i> || <i>Ciphertext One-Time Pad</i> )<br>
						<b>MAC<sub>2</sub></b> = Skein-512( <i>MAC Key<sub>2</sub></i> || <i>Nonce<sub>1</sub></i> || <i>Nonce<sub>2</sub></i> || <i>User Callsign</i> || <i>Pad Identifier</i> || <i>Ciphertext One-Time Pad</i> )<br>
						<br>
						<b>Row Cascade MAC</b> = <i>MAC<sub>1</sub></i> &oplus; <i>MAC<sub>2</sub></i><br>
					</div>
					<ul>
						<li>
							The resulting MAC tag is stored along with the other information for each row. When the 
							database is being loaded on a client machine, the program will calculate the MAC again 
							for each database row and verify that the hash digest matches the stored MAC tag for the row. 
							If there is a match for each row then no tampering has occurred, otherwise a warning will be 
							shown to the user. If the warning is shown, then the user should abandon the database of 
							one-time pads and look to transfer a new set.
						</li>
						<li>
							In version 1.5 of the program, the database is verified only when loading the pads initially 
							after they have been exported and transported. Currently after the pads are verified and 
							decrypted, the database is saved to the client PC in an unencrypted state. Running the 
							application and browser profile from inside a TrueCrypt volume is still recommended for this 
							release to keep the one-time pads encrypted locally on the disk. In the future, version 2.0 
							of the program will have the one-time pad database be fully encrypted and authenticated at 
							all times. Each one-time pad row will need to be verified and decrypted before sending or 
							receiving a message. The reason for why this functionality is not available in version 1.5 
							is that the application needs to be converted to a Single Page Application first. Currently 
							each web page is run separately and there is no in memory data sharing between pages. 
							Converting to a single page application will reduce code duplication and mean the master 
							password only needs to be entered once on startup, not once for each page opened.
						</li>
						<li>
							The pad database information which is stored in the client database (program version, 
							custom user preferences, server address, server key, user callsign and list of group user 
							nicknames) is also authenticated using the same cascade MAC. This is checked before 
							decrypting and importing the pad database information. In version 2.0 it will be verified 
							each program load to ensure database integrity.
						</li>
					</ul>
					
					<h3 id="database-index-authentication">Database index authentication</h3>
					<p>
						The program also creates a MAC of the database index for each user's set of one-time pads 
						by combining the pad index numbers for each row and then creating a cascade MAC. This 
						ensures that the all user's one-time pads in the database have not been added, swapped, 
						reordered, removed or otherwise tampered with. 
					</p>
					<p>
						The following describes the database index MAC:
					</p>
					<div class="formulas">
						<b>MAC Key<sub>1</sub></b> = A 512 bit random key for Keccak-512 generated by the TRNG<br>
						<b>MAC Key<sub>2</sub></b> = A different 512 bit random key for Skein-512 generated by the TRNG<br>
						<b>User Callsign</b> = The user callsign (e.g. 'alpha', 'bravo', 'charlie' etc) of the set of pads being authenticated<br>
						<b>Pad Index Number</b> = The index number of the row in the database for the user's set of pads<br>
						<br>												
						<b>MAC<sub>1</sub></b> = Keccak-512( <i>MAC Key<sub>1</sub></i> || <i>User Callsign</i> || <i>Pad Index Number<sub>0</sub></i> || <i>Pad Index Number<sub>1</sub></i> || <i>Pad Index Number<sub>2</sub></i> || ... )<br>
						<b>MAC<sub>2</sub></b> = Skein-512( <i>MAC Key<sub>2</sub></i> || <i>User Callsign</i> || <i>Pad Index Number<sub>0</sub></i> || <i>Pad Index Number<sub>1</sub></i> || <i>Pad Index Number<sub>2</sub></i> || ... )<br>
						<br>
						<b>Index Cascade MAC</b> = <i>MAC<sub>1</sub></i> &oplus; <i>MAC<sub>2</sub></i><br>
					</div>
					<ul>
						<li>
							When a message is received or sent that pad is deleted from the database so the pad index 
							MAC needs to be updated every time a new message is received or sent. This functionality 
							will be added in version 2.0 when the database will be encrypted and authenticated at all 
							times. At the moment in version 1.5, the full verification of the index is only performed 
							as part of the initial importing of the one-time pads after transportation. This is 
							mainly to verify that the transfer took place without tampering. Version 2.0 will be much 
							more comprehensive and ensure that the database integrity and authenticity is valid at all 
							times.
						</li>
						<li>
							Including the user callsign in the MAC means that an attacker cannot swap out one-time pads 
							from one user into another user's set of pads, forcing a two-time pad situation and allowing 
							cryptanalysis.
						</li>
					</ul>
					
					
					<h2 id="database-key-wrapping">Protection of database encryption and authentication keys</h2>
					<p>
						The actual database encryption and authentication keys which were generated by the TRNG are 
						stored in inside the database with the rest of the other information. To protect these keys 
                        while they reside in unprotected storage a simple 
                        <a href="https://en.wikipedia.org/wiki/Key_Wrap">key wrapping</a> construction is used.
					</p>
					
					<h3 id="database-pbkdf">Database master key derivation</h3>
					<p>
						To encrypt the actual database encryption and authentication keys, a master key is created 
						by deriving it from a password, two salts and two separate Database Password Based Key 
						Derivation Functions (PBKDFs). The following describes the cascade PBKDF construction:
					</p>
					<div class="formulas">
						<b>Password</b> = A strong password/passphrase entered by the user<br>
						<b>Salt<sub>1</sub></b> = A 768 bit random salt generated by the TRNG to be used with the Keccak PBKDF<br>
						<b>Salt<sub>2</sub></b> = A different 768 bit random salt generated by the TRNG to be used with the Skein PBKDF<br>
						<b>Keccak Iterations</b> = The number of iterations to be performed by the Keccak PBKDF with the default set at 10,000<br>
						<b>Skein Iterations</b> = The number of iterations to be performed by the Skein PBKDF with the default set at 10,000<br>
						<br>
						<b>Intermediate Key</b> = PBKDF2-Keccak-512( <i>Password</i>, <i>Salt<sub>1</sub></i>, <i>Keccak Iterations</i> )<br>
						<b>Master Key</b> = PBKDF-Skein-512( <i>Intermediate Key</i>, <i>Salt<sub>2</sub></i>, <i>Skein Iterations</i> )
					</div>
					<ul>
						<li>
                            The first PBKDF is <a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a> with the 
                            Keccak-512 hash function. The output key size is set at 
							512 bits, the default number of iterations is set at 10,000 and a 768 bit random salt which was 
                            generated by <a href="information.html#trng-photo">the TRNG</a> is used.
						</li>
						<li>
                            <a href="http://crypto.stackexchange.com/a/15825">Keccak can be used in conjunction with HMAC</a> 
                            which is what PBKDF2 uses internally. The reason to use Keccak instead of 
                            <a href="https://en.wikipedia.org/wiki/SHA-2">SHA2</a> is because it is a 
                            newer hash function and it is not designed by the NSA. Anything designed by the NSA is avoided 
                            by this program in case it has deliberate secret weaknesses that are unknown to the academic 
                            community. An algorithm designer is in the best position to design an algorithm 
							with a subtle weakness. In the case of SHA2 a weakness may not be discovered for many years if 
                            academia is well behind the state of the art in cryptography. We know at one point 
                            <a href="https://en.wikipedia.org/wiki/Data_Encryption_Standard#NSA.27s_involvement_in_the_design">the NSA were 20 years ahead in cryptography</a> 
                            when they knew about differential cryptanalysis before anyone else. They are likely still 
                            ahead by a large margin. Using Keccak which was the winner in an open competition and which 
                            has a design which is completely open is considered much safer. In comparison to SHA2, Keccak 
                            should provide better entropy in the derived key, however it may be a lot faster in hardware 
                            which would provide a slightly better advantage for an attacker performing a brute force attack. 
                            However the main attacker to be considered is the NSA and we can reasonably assume they have dedicated 
                            <a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASICs</a> and other 
							hardware for cracking password hashes which were derived using PBKDF2-SHA1 or PBKDF2-SHA2 simply 
							because everyone in the world is using those algorithms. If everyone uses the same algorithms 
							recommended by the US government which is also running worldwide mass surveillance programs then 
							this makes the NSA's job much easier. They can focus their efforts on attacking only a few 
							algorithms at a much cheaper cost. By using the newer Keccak algorithm this forces the NSA to 
							expend more money building new dedicated ASICs or re-engineer their supercomputer code just to 
							crack an encrypted database created by this program.
						</li>
						<li>
							The second PBKDF uses the Skein hash function. The output key size is set at 512 bits, the 
							default number of iterations/repetitions is set at 10,000 and a separate 768 bit random salt 
							which was generated by the TRNG is used. The resulting 512 bit <i>Intermediate Key</i> from 
							the previous PBKDF2-Keccak function is passed in as the <i>Password</i> for this function.
						</li>
						<li>
                            The Skein PBKDF method is described in section 4.8 of 
                            <a href="https://www.schneier.com/skein1.3.pdf">The Skein Hash Function Family</a> specification 
							document (v1.3) - Skein as a Password-Based Key Derivation Function (PBKDF). Quoting 
							the document:<br>
							<i>"The application stores a random seed S, asks the user for a password P, and then 
							performs a long computation to combine S and P." ... "An even simpler PBKDF is to simply create 
							a very long repetition of S and P; e.g., S || P || S || P || S ..., and hash that using Skein. (Any other 
							optional data can also be included in the repetition.) This approach is not ideal with a normal 
							hash function, as the computation could fall into a loop. But in Skein, every block has a 
							different tweak and is thus processed differently."</i>
						</li>
						<li>
							For added security an option exists in the user interface to use custom iteration counts. 
							The user can decrease the number of iterations for slower portable devices and use a longer 
							password to compensate. The user may also choose to increase the iteration counts to make 
							the database more resilient to attack. The default of 10,000 iterations for each of the 
							PBKDFs is a good balance between strength and slow speed of the JavaScript runtime engine.
						</li>
						<li>
							The user can also choose not store the number of Keccak or Skein iterations with the rest of 
							the database. The user would remember the iterations or write them down separately on a 
							piece of paper. This may be useful if passing through airport security and there is a high 
							likelihood of the data being confiscated and copied. This forces an attacker with only the 
							database to try every iteration count for every password permutation. To counter an attacker 
							simply caching the results of previous iteration counts and running the PBKDF on one password 
							at a time, the number of iterations are appended to the end of the salt at runtime. This 
							forces the attacker to do the full PBKDF iterations for every reasonable iteration count 
							the user could have chosen e.g. 1 - 10,000+ then repeat that for all possible password 
							permutations.
						</li>
						<li>
							The total length of the two salts is the same length of all the database keys (256 bits 
							AES-CTR + 256 bits Salsa20 + 512 bits Keccak + 512 bits Skein) which adds up to 1536 bits. 
							Each 768 bit salt is fed into a different PBKDF. Normally passwords do not contain much 
							entropy, so the salts which are randomly generated by the TRNG are used as a backup to add 
							additional entropy to safely secure the database keys.
						</li>
						<li>
							Another option exists in the user interface to store the two 768 bit salts (1536 bits 
							concatenated together) as a separate keyfile. The advantage of this is to store the 
							keyfile on a separate storage device (e.g. MicroSD card) or written down on a piece of paper 
							which can be easily hidden if the database is at risk of being compromised in transit. If 
							an attacker can confiscate or steal the primary device (e.g. notebook PC) which has the 
							encrypted database but can't find the keyfile as well then it is practically impossible to 
							crack the database encryption in any reasonable timeframe. Future versions may allow this 
							keyfile to be hidden inside an image file using steganography.
						</li>
						<li>
                            In the future the program may support 
                            <a href="https://password-hashing.net/submissions/specs/Argon-v3.pdf">Argon2</a> which was 
                            the winner in the <a href="https://password-hashing.net/candidates.html">Password Hashing Competition</a>. 
                            At the time of writing, this standard is not currently finalised and there is no library 
                            support for it currently.
						</li>
					</ul>
					
					<h3 id="subkey-derivation">Sub key derivation</h3>
					<p>
						Four sub keys are derived from the master key and are used to encrypt the actual database 
                        encryption and authentication keys. This is basically a simple 
                        <a href="https://crypto.stackexchange.com/questions/15673/security-of-kdf1-and-kdf2-hash-based-kdfs">KDF2</a> 
                        construction but uses a cascade of two hash functions for each counter value to protect against 
                        flaws in either algorithm. The newer hash functions used are already secure against 
                        <a href="https://en.wikipedia.org/wiki/Length_extension_attack">length extension attacks</a> and 
                        do not need HMAC. The following describes the cascade sub key derivation:
					</p>
					<div class="formulas">
						<b>Master Key</b> = The 512 bit master key derived from the cascade PBKDF used earlier<br>
						<b>Counter<sub>i</sub></b> = A 32 bit numeric counter to be combined with the hash function e.g. (<code>00000001</code>, <code>00000002</code>, ... in hexadecimal)<br>
						<br>
						<b>Derived Key<sub>1</sub></b> = Keccak-512( <i>Master Key</i> || <i>Counter</i><sub>1</sub> ) &oplus; Skein-512( <i>Master Key</i> || <i>Counter</i><sub>1</sub> )<br>
						<b>Derived Key<sub>2</sub></b> = Keccak-512( <i>Master Key</i> || <i>Counter</i><sub>2</sub> ) &oplus; Skein-512( <i>Master Key</i> || <i>Counter</i><sub>2</sub> )<br>
						<b>Derived Key<sub>3</sub></b> = Keccak-512( <i>Master Key</i> || <i>Counter</i><sub>3</sub> ) &oplus; Skein-512( <i>Master Key</i> || <i>Counter</i><sub>3</sub> )<br>
						<b>Derived key<sub>4</sub></b> = Keccak-512( <i>Master Key</i> || <i>Counter</i><sub>4</sub> ) &oplus; Skein-512( <i>Master Key</i> || <i>Counter</i><sub>4</sub> )<br>
					</div>
					<ul>
						<li>
							A simple KDF1 construct to get encryption and authentication keys from a master key would 
							apply the hash function twice. Once with the <i>Master Key</i> and a unique <i>Counter</i> 
							to make an encryption key, and again with the <i>Master Key</i> and another unique 
							<i>Counter</i> gain a unique MAC key. If the keys used for encryption is compromised 
							it is computationally hard to find a pre-image for the one-way hash function to determine 
							the <i>Master Key</i> or the derived MAC key. Similarly if the MAC key is compromised it is 
							hard to reverse the process to find the master key or encryption key. This cascade construct 
							performs two hashes for each derived key, once using Keccak on the <i>Master Key</i> and 
							unique <i>Counter</i>, then again with the Skein algorithm and another unique <i>Counter</i>. 
							Finally it XORs the resulting random hash digests together to produce the derived key. This 
							adds additional assurances that the derived key will not be easily reversed if there is a 
							flaw in either algorithm discovered in the future.
						</li>
						<li>
							The resulting derived keys are 512 bits in length. The first and second derived keys are 
							used for AES-CTR and Salsa20. Because the key lengths for these encryption algorithms are 
							only 256 bits in length, these two derived keys are truncated to just the first 256 bits. 
							The third and fourth derived keys which are used for Keccak and Skein remain at 512 bits.
						</li>
					</ul>
					
					<h3 id="encryption-and-authentication-of-database-keys">Encryption and authentication of database keys</h3>
					<p>
						The following describes the encryption and authentication of the actual database keys using the 
						derived keys from earlier:
					</p>
					<div class="formulas">
						<b>Database Keys</b> = The actual AES-CTR, Salsa20, Keccak and Skein database keys, concatenated together<br>
						<b>Nonce<sub>1</sub></b> = A static 96 bit nonce for AES-CTR (<code>000000000000000000000000</code> in hexadecimal)<br>
						<b>Nonce<sub>2</sub></b> = A static 64 bit nonce for Salsa20 (<code>0000000000000000</code> in hexadecimal)<br>
						<b>Counter<sub>1</sub></b> = A 32 bit counter for AES-CTR, starting at 0 and incrementing by 1 for each block being encrypted<br>
						<b>Counter<sub>2</sub></b> = A 64 bit counter for Salsa20, starting at 0 and incrementing by 1 for each block being encrypted<br>
						<br>
						<b>Keystream<sub>1</sub></b> = <i>AES-CTR</i>( <i>Derived Key<sub>1</sub></i>, ( <i>Nonce<sub>1</sub></i> || <i>Counter<sub>1</sub></i> ))<br>
						<b>Keystream<sub>2</sub></b> = <i>Salsa20</i>( <i>Derived Key<sub>2</sub></i>, ( <i>Nonce<sub>2</sub></i> || <i>Counter<sub>2</sub></i> ))<br>
						<b>Encrypted Database Keys</b> = <i>Keystream<sub>1</sub></i> &oplus; <i>Keystream<sub>2</sub></i> &oplus; <i>Database Keys</i><br>
						<br>
						<b>MAC<sub>1</sub></b> = Keccak-512( <i>Derived Key<sub>3</sub></i> <i>Encrypted Database Keys</i> )<br>
						<b>MAC<sub>2</sub></b> = Skein-512( <i>Derived Key<sub>4</sub></i> <i>Encrypted Database Keys</i> )<br>
						<b>Cascade MAC</b> = <i>MAC<sub>1</sub></i> &oplus; <i>MAC<sub>2</sub></i><br>
					</div>
					<ul>
						<li>
							After encryption and authentication, the encrypted database keys and the MAC are stored in the 
							database. To decrypt the database, a user will enter their password, load the keyfile and 
							set the number of iterations. It will perform the same steps above to generate the derived Keccak 
							and Skein keys, recreate the MAC against the stored encrypted database keys, then match that 
							against the stored MAC. Any incorrect match may mean an incorrect password, keyfile or number 
							of iterations used. Alternatively a more serious issue could be that someone has tampered 
							with the database.
						</li>
					</ul>
															
					
					<h2 id="using-html5">Using HTML5</h2>
					<p>
						<a href="http://www.matasano.com/articles/javascript-cryptography/">Matasano Security raises some points</a> 
						about JavaScript cryptography and how JavaScript being delivered by the web server is insecure. 
						There are <a href="http://blog.meadhbh.org/2013/08/in-defense-of-javascript-cryptography.html">definite sensible</a> 
						and <a href="http://log.nadim.cc/?p=33">secure solutions</a> to the problems they raised. Also if you read 
						the FAQ, <a href="faq.html#matasano-article-discussion">all of their other concerns have been mitigated</a> 
						one by one.
					</p>
					<p>
						Most points they made are not applicable for this software due to the fact that the source code is 
						downloaded as a <a href="http://en.wikipedia.org/wiki/Tar_%28computing%29">.tar.gz</a> archive 
						file and users are expected to verify the file's GPG signature with the one from this website to 
						ensure its authenticity. From there the code can be run <i>locally</i> from the machine by going to 
						the directory and running index.html which will load the website and code into the browser. This means all 
						code is always running locally from the local hard drive and the web address will be similar to 
						<code>file:///media/truecrypt1/jericho/client/index.html</code>. All the executable code is self 
						contained and does not rely on any server delivered JavaScript at all. This itself mitigates 
						the majority of the problems the Matasano Security article raised.
					</p>
					<p>
						HTML5 has more advantages than disadvantages. It's easier and faster to develop with. New APIs allow for 
						<a href="http://www.w3.org/TR/WebCryptoAPI/">cryptography</a>, 
						<a href="http://www.w3.org/TR/webstorage/">persistent database storage</a>, 
						<a href="http://dev.w3.org/html5/postmsg/">messaging</a> and 
						<a href="http://www.w3.org/TR/FileAPI/">file management</a>. Browsers are first in line for security 
						updates and the best ones are open source and trustworthy. People rely on browsers to have good security 
						to do their internet banking and shopping online. The source code does not need to be compiled. 
						You can verify the source code being run live in the browser using Chromium or Firefox built-in Web 
						Development tools or with addons like <a href="http://getfirebug.com">Firebug</a>. This allows you to 
						verify the code is doing exactly what it should be. HTML5 is cross platform, one code base can literally 
						run on Windows, Linux, Mac, phones and tablets simply with the latest web browser. One of the goals of 
						the project is to get a truly secure chat program functioning on 
						an open hardware platform and an open operating system like 
						<a href="http://en.wikipedia.org/wiki/Firefox_OS">Firefox OS</a>. This is a true open source OS for 
						smartphones and tablets from a reputable organisation that believes that 
						<a href="http://www.mozilla.org/en-US/about/manifesto/">individual's security and privacy on the internet 
						is fundamental</a>.
					</p>
					<p>
						Currently this software has been tested to work in 
						<a href="http://www.mozilla.org/en-US/firefox/new/">Firefox</a>, 
						<a href="http://www.chromium.org">Chromium</a> and <a href="http://www.google.com/chrome/">Google Chrome</a>. 
						Some of the other browsers have not implemented the <a href="http://www.w3.org/TR/WebCryptoAPI/">Web Crypto API</a> 
						yet. From version 1.4 onwards, the layout will be responsive and will work on desktops, tablets and mobiles. 
						Some more work and testing is still required to get it working nicely on mobile. In particular a method to 
						load the one-time pads into the program using later versions of Android. Using Firefox is recommended as 
						they are open source and are not involved in the spy scandal with 
						<a href="https://en.wikipedia.org/wiki/PRISM_%28surveillance_program%29">PRISM</a>. Unfortunately nobody 
						can say for sure about that <a href="http://en.wikipedia.org/wiki/PRISM_%28surveillance_program%29#Companies">with Google</a>. 
						Chromium may be another alternative but the proprietary Google Chrome is not recommended.
					</p>
					<p>
						It is recommended to run the browser profile from inside a 
						<a href="https://en.wikipedia.org/wiki/Truecrypt">TrueCrypt</a> volume to protect the one-time pads when 
						they are stored inside the browser storage. Future versions of the software will encrypt the one-time pads 
						within the program before storing locally.
					</p>					
					<p>
						The program is built using sound, provably strong cryptography. The design and implementation to bring the 
						solution together uses secure cryptographic primitives (<a href="https://en.wikipedia.org/wiki/Skein_hash">Skein</a> and 
						<a href="https://en.wikipedia.org/wiki/Keccak">Keccak</a>) for authentication which were designed by 
						publically reputable and trustworthy cryptographers. We have avoided using algorithms from 
						the NIST who have been shown to be heavily influenced by the NSA. The NSA have been 
						<a href="http://www.theguardian.com/world/2013/sep/05/nsa-gchq-encryption-codes-security">secretly weakening</a> 
						and promoting weak or broken public encryption standards.
					</p>
					<p>					
						The main crypto library this program uses is <a href="https://code.google.com/p/crypto-js/">CryptoJS</a>. 
						There were some other libraries that would be good to use but they either did not work in a 
						<a href="http://www.html5rocks.com/en/tutorials/workers/basics/">HTML5 Web Worker</a> which makes 
						the hashing process take significantly longer and 
						<a href="https://en.wikipedia.org/wiki/Blocking_%28computing%29">blocks</a> 
						the user interface, or their outputs couldn't be verified from the reference test vectors. Some more 
						SHA-3 finalists would be nice to include from the recent competition however there is a lack of hash 
						algorithms implemented in JavaScript. It is important to verify that the code can produce the same hash 
						outputs as the test vectors from the specification documents. This ensures the program is not using a 
						faulty or backdoored version of the algorithm that gives incorrect results.
					</p>
					
					
					<h2 id="json-rest-api">REST API using JSON</h2>
					<ul>
						<li>
							The client browsers communicate to and from the server using <a href="http://en.wikipedia.org/wiki/JSON">JSON</a> 
							and the <a href="http://en.wikipedia.org/wiki/REST_API">REST API</a> on the server. The server side 
							code is currently written for the latest version of PHP 5 using best security practices for 
							protection against SQL injection and other attacks. This will likely be rewritten in a 
							different language in the next release e.g. NodeJS to have a common cryptographic library 
							base across the client and server.
						</li>
						<li>
							The server sends <a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a> HTTP 
							headers so that the client browsers can connect and make a cross-origin request. This is needed because 
							the program is run locally from the <code>file:///</code> location and not served by a webserver. If 
							the JavaScript code was served from a web server it could let an attacker perform a 
							<a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">MITM attack</a> and alter the code, 
							this could then make the user send unencrypted messages and they would not be any wiser.
						</li>
						<li>
							For now the browsers use an <a href="http://en.wikipedia.org/wiki/Ajax_%28programming%29">AJAX</a> 
							request to send/receive data to/from the server. The reason for this is that the chat can be delayed 
							like email (encrypted messages remain on the server until they are received), or realtime if users 
							are connected at the same time. If a user is connected it will check for new messages from the server 
							every 3 seconds which is fast enough to appear as realtime and does not stress the server too much.
						</li>
					</ul>
					<p>
						A summary of the request/response protocols are shown below:
					</p>
					<h3>Send message</h3>
					<p>
						This is the request the client makes when sending a message.
					</p>
					<p>
						<img src="img/api-send-message-json.png">
					</p>
					<h3>Send message server response</h3>
					<p>
						This is the response the server makes after it has received a request to send a message.
					</p>
					<p>
						<img src="img/api-send-message-server-response-json.png">
					</p>
					<h3>Receive messages request</h3>
					<p>
						This is the request each client makes every 3 seconds. This will get any new messages from the server 
						for the user making the request.
					</p>
					<p>
						<img src="img/api-receive-messages-json.png">
					</p>
					<h3>Receive messages response</h3>
					<p>
						This is the response the server will make after receiving a request from a client for retrieving new messages.
					</p>
					<p>
						<img src="img/api-receive-messages-response-json.png">
					</p>
					<h3>Initiate auto nuke request</h3>
					<p>
						This is the request a client makes if they want to wipe the all the other chat group user's 
						local one-time pad databases. It is very disruptive and designed for use only in an emergency. 
						This command is sent encrypted and authenticated via the secure message channel. This is so 
						only a valid user with the set of one-time pads can trigger an auto nuke. An attacker with 
						access to the server cannot change anything to trigger the chat group users to delete 
						their local databases.
					</p>
					<p>
						To trigger the request, the user will visit a separate screen in the user interface and click 
						a button. The client will send a regular message with the string code "<code>init auto nuke</code>". 
						This will be encrypted with the one-time pad, authenticated with the MAC and sent to the server 
						like a regular message. The initiating user's current local database of one-time pads will then 
						be wiped and their screen cleared.
					</p>
					<h3>Auto nuke initiated response</h3>
					<p>
						If a chat group user is checking for new messages and an authentic message comes through with the 
						code "<code>init auto nuke</code>", instead of receiving and processing new messages, the user's 
						client will show a notification that the auto nuke has been initiated by the user who initiated it, 
						then the program will immediately wipe their local database of any data and clear the screen of 
						any sent or received messages.
					</p>
					
					
					<h2 id="message-encoding">Message encoding</h2>
					<p>
						Each one-time pad is made up of 192 bytes which is 384 hexadecimal symbols or 1536 binary digits. See the 
						table below for more information:
					</p>
					<p class="diagram">
						<img src="img/pad-encoding.png">
					</p>
					<p>
						Each message is made up of three main parts, the pad identifier, the message parts and the message authentication code. The 
						one-time pad is used to encrypt the message parts and the MAC tag.
					</p>
					<p class="diagram">
						<img src="img/message-encoding.png">
					</p>			
					<p>
						This can be further broken down to the individual message parts. See below for the length of each part:
					</p>
					<p class="diagram">
						<img src="img/message-encoding-full.png">
					</p>
					<ul>
						<li>
							At the moment the program only supports messages typed using the 
							<a href="http://en.wikipedia.org/wiki/Ascii#ASCII_printable_characters">ASCII printable character set</a>. 
							This is roughly	all the characters you can see on a standard US keyboard. In practicality this limits 
							the languages that can be used to English and ones that use the 
							<a href="http://en.wikipedia.org/wiki/ISO_basic_Latin_alphabet">basic Latin alphabet</a> at the moment. 
							This is for ease of development at the moment and the program will support other languages with UTF-8 
							in the future.
						</li>
						<li>
							All messages that are sent/received are encoded to 
							<a href="http://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a> format first which is just stored 
							in a normal JavaScript string. This is to make transport using JSON easier rather than trying to 
							send UTF-8 encoded data over the wire. A hexadecimal symbol 
							(<a href="http://en.wikipedia.org/wiki/Nibble">Nibble</a>) is 4 bits, and two hexadecimal symbols 
							makes 8 bits (one <a href="http://en.wikipedia.org/wiki/Octet_%28computing%29">Octet/Byte</a>) 
							and can be represented as a single ASCII character.
						</li>
						<li>
							The <b>Pad identifier</b> is the first 7 bytes (56 bits) from the one-time pad. This identifies to 
							the receiver which pad should be used to decrypt the message. This is used rather than sending the 
							sequence number of the one-time pad to remain in sync with the other users as that could reveal to 
							an attacker the number of messages sent so far.
						</li>
						<li>
							The maximum message length has been set at 115 bytes (115 ASCII characters) for now. This is slightly 
							less than the size of a <a href="http://en.wikipedia.org/wiki/Tweet_%28Twitter%29">tweet</a> 
							(140 characters) or an <a href="http://en.wikipedia.org/wiki/SMS">SMS</a> (160 characters). This is 
							because generating enough random data takes a long time. Making a message length longer than that, 
							where the one-time pad may or may not be fully used is wasteful. If users need more than 115 
							characters they can simply send a second message. In future a new feature will be added to allow 
							a message to be spread over multiple one-time pads.<br>
							<br>
							If a message is less than 115 bytes in length it is padded to the right (up to the maximum 115 bytes) 
							with random bits generated from the Web Crypto API. This hides the actual length of the message to 
							frustrate any cryptanalysis. For example if no padding was added and the message was simply "hi" then 
							the ciphertext would be the same length which could aid the attacker. Of course there are a few other 
							words with only two letters which allows for some uncertainty. However if the message is padded up to the 
							full 115 bytes each time, then an attacker knows nothing about the true length of the message, 
							only that it is somewhere between 1 and 115 bytes long.<br>
							<img class="listImage" src="img/message-padding.png" alt="Message padding">							
						</li>						
						<li>
							The <b>Actual message length</b> is the true message length without any padding. It is an aid in the decryption 
							process so it can remove the correct number of padding bytes from the end of the message and reveal the original 
							plaintext automatically. This field is always 1 byte in length which is enough to represent the message length. 
							For example, if the message was 70 bytes long, then the number 70 is converted to binary and left padded (if necessary) 
							to be 8 bits long. 8 bits can have 2<sup>8</sup> (256) possible values which represents the numbers from 0 to 255. 
							One byte of information can store the actual message length of 1 to 115 bytes easily. The actual message length is 
							also encrypted with one byte from the one-time pad so it is impossible for an attacker to know the actual message 
							length without the one-time pad. An attacker only knows that the length of a message is between 1 and 
							115 bytes. When decrypting the message, the message length value is checked to make sure it is in the 
							correct range. This helps avoid denial of service and/or buffer overflow attacks.
						</li>
						<li>
							A <a href="http://en.wikipedia.org/wiki/Unix_timestamp">UNIX timestamp</a> is sent along with the 
							message in the <b>Message sent timestamp</b> field to signify when the message was sent from the sender's 
							computer. This is converted to binary and sent with the message packet. 5 bytes are reserved for this. It could 
							easily be 4 bytes (32 bits), but an extra byte was added to avoid the 
							<a href="http://en.wikipedia.org/wiki/Year_2038_problem">year 2038 problem</a>. 
							This timestamp is also encrypted with 5 bytes of the one-time pad. This prevents an attacker from 
							interfering with the date or time of the message which could be critical in some circumstances. It is 
							also used for correctly reordering messages on the client side when retrieving multiple messages from 
							the server. This prevents an attacker reordering messages from them gaining access to the server or by 
							delaying server responses.
						</li>
						<li>
							The final part of the encoding is the <b>MAC tag</b>. This MAC tag is sent along with each message for 
							authentication and integrity to ensure that the message has not been tampered with. The MAC tag is 
							also encrypted with part of the one-time pad so it is also information-theoretically secure. The 
							process is explained in depth <a href="#message-authentication">here</a>.
						</li>
					</ul>
					
					
					<h2 id="encryption-process">Encryption process</h2>
					<ul>
						<li>
							The program first receives the plaintext message from the user from the text box when they click the 
							<i>Send message</i> button. 
						</li>
						<li>
							Then it does a lookup on the user's local database of one-time pads and selects the first available 
							one-time pad allocated to that user for sending messages. The one-time pads for sending/encrypting 
							messages are evenly pre-allocated and grouped under each user in the chat group e.g. alpha, bravo, 
							charlie etc. This prevents one user from encrypting a messsage using the same one-time pad as another 
							user.
						</li>
						<li>
							Once a one-time pad has been selected, it removes it from the local database and splits it into the pad 
							identifier, the message parts and the MAC parts. The encryption process is as follows:
						</li>
					</ul>
					<p class="diagram">
						<img src="img/encryption-process.png" alt="Encryption process">
					</p>
					<ul>
						<li>
							In step one, the plaintext with padding, the message length and the timestamp are converted to binary 
							and concatenated together.
						</li>
						<li>
							In step two, because some of the bits of the 40 bit UNIX timestamp can be predictable, this could leave 
							a <a href="https://en.wikipedia.org/wiki/Crib_%28cryptanalysis%29">crib</a> for an attacker and they 
							could recover those few bits of the key. This however would not compromise the remainder of the plaintext 
							because each bit of the one-time pad is random and independent from the rest. For example, if the 
							timestamp was 1406440512 for 
							2014-07-27 at 5:55am in UTC then that would convert to binary as <code>00000000 01010011 11010100 10010100 01000000</code>. 
							If we compare another time in the future, 1503040500 for 2017-08-18 at 7:15am in UTC then that would 
							convert to binary as <code>00000000 01011001 10010110 10010011 11110100</code>. The first 12 bits are 
							the same in both timestamps even though the dates are years apart. This is because the timestamp field 
							is larger than currently required in order to future proof the protocol. If it was the usual 32 bits then 
							eventually there would be incorrect dates and times shown in the program after 
							<a href="http://en.wikipedia.org/wiki/Year_2038_problem">19 Jan 2038</a>.<br>
							<br>
							To remove this as a possiblity for being a crib, the program randomly reverses the binary message parts 
							(including the plaintext with padding, the message length and the timestamp) depending on the second 
							last byte in the one-time pad. It does this by converting this byte to an integer value (0 - 255), 
							then uses that number modulo 2. This will return a random integer of 0 or 1. A one will mean the 
							message parts get reversed while a zero will mean they stay the same. This means that every message, 
							an attacker does not know for certain whether the timestamp is at the front or end of the message 
							parts. They also do not know whether the true plaintext begins at the start of the message or the end. 
							Because all users have the same one-time pad, they can reverse this transformation to get the message 
							parts back in proper order after decryption. This transformation has a similar purpose to 
							<a href="https://en.wikipedia.org/wiki/Russian_copulation">Russian copulation</a>.
						</li>
						<li>
							In the third step, the <a href="https://en.wikipedia.org/wiki/Exclusive_disjunction">Exclusive OR</a> (XOR) 
							operation is what does the encryption. Each bit of the plaintext is encrypted with one bit of the 
							one-time pad. With a truly random one-time pad the 
							<a href="http://users.telenet.be/d.rijmenants/en/onetimepad.htm">encryption is unbreakable even in theory</a>.
						</li>
						<li>
							The final step concatenates the pad identifier to the ciphertext message parts. The pad identifier helps 
							the other users determine which one-time pad was used to encrypt the message.
						</li>
						<li>
							Once the message has been encrypted, the MAC is created using a random MAC algorithm that was 
                            selected and then encrypted with part of the one-time pad. This process is explained 
                            <a href="information.html#message-authentication">further on</a>. 
							The MAC is concatenated to the end of the ciphertext and sent with the message to the server. 
                            The server holds the message until all the other users have retrieved it.
						</li>
					</ul>
					
					
					<h2 id="decryption-process">Decryption process</h2>
					<p>
						The user first checks for encrypted messages on the server that are not sent by them and have not been 
						read already by them. This will retrieve all other messages sent by users in the same chat group. 
						Once the encrypted messages have been retrieved by the user, the messages are marked as read on the server 
						by them. Once all users have read the message, they are deleted from the server in a cleanup process which 
						runs every 30 seconds. The process for decryption is generally the same as encryption but in reverse order. 
						For each encrypted message that is received:
					</p>
					<ul>
						<li>
							The program selects the sender of the message e.g. alpha, bravo, charlie etc and does a lookup on the 
							local database of one-time pads for that user. The program selects the pad identifier (first 7 bytes) 
							from the ciphertext which will match the first 7 bytes from one of the one-time pads in the database. 
							The pad identifier for each one-time pad is stored in a separate field which makes searching faster. 
							It then retrieves the one-time pad for the message and takes off the pad identifier.
						</li>
						<li>
							The MAC is then decrypted with the last 64 bytes of the one-time pad. Using the ciphertext message 
							parts, the one-time pad and the random algorithm for the MAC, the MAC is calculated. If this matches 
							the MAC sent, then the message is valid and has not been tampered with. Decryption of the message 
							will follow. If the message matches the MAC sent with the message then an 'Authentic' status is 
							displayed to the user. If the message is not valid, the user is warned that tampering has occurred 
							and the decryption process will not be attempted.
						</li>
						<li>
							The one-time pad message parts is then XORed with the ciphertext message parts (including the 
							plaintext with padding, message length and timestamp). This returns the decrypted text with padding, 
							the actual message length and the time the message was actually sent.
						</li>
						<li>
							Depending on the second last byte of the key, the decrypted message parts are returned to their original 
							order (unreversed) if that transformation was made in the encryption process.
						</li>
						<li>
							The message length part is read and this gets the length of the actual message in bytes. Reading 
							from the start of the plaintext message up to the message length will retrieve the actual plaintext 
							without padding.
						</li>
						<li>
							The one-time pads for any messages received and verified authentic are then deleted from the user's 
							local database.
						</li>
					</ul>
	
					
					<h2 id="message-authentication">Message authentication code (MAC)</h2>
					<p>
						The one-time pad is vulnerable to a 
						<a href="https://en.wikipedia.org/wiki/Bit-flipping_attack">bit-flipping attack</a> if not authenticated 
						with a MAC. Therefore the program calculates and sends a one-time information-theoretically secure MAC 
						with each message. Both users have a shared secret, which is the one-time pad for each message so the MAC 
						can be calculated and verified by either person. The construction of this is as follows: 
					</p>
					<p class="diagram">
						<img src="img/mac-method.png" alt="MAC method">
					</p>
					<ul>						
						<li>
							For each message sent, a random MAC algorithm from a pool of algorithms is chosen to authenticate the 
							message. This provides some protection in the case that a fundamental flaw is discovered in one of the 
							hash algorithms in the future. It also makes message forgery considerably more difficult as an attacker 
							needs to guess the correct hash algorithm as well. Currently there are only 2 hash algorithms that 
							are used with the program due to the lack of JavaScript library support. More may be 
							added in future. Potentially some of the 
							<a href="http://en.wikipedia.org/wiki/Nist_hash_function_competition#Finalists">NIST hash function competition finalists</a>. 
							Currently the hash functions used are the 512 bit versions of 
							<a href="http://en.wikipedia.org/wiki/SHA-3">Keccak</a> and 
							<a href="http://en.wikipedia.org/wiki/Skein_hash">Skein</a>. These 512 bit hashes will provide 
							2<sup>256</sup> collision resistance and 2<sup>512</sup> pre-image resistance against regular computers. 
							They will provide 
							<a href="https://crypto.stackexchange.com/questions/419/what-security-do-cryptographic-sponges-offer-against-generic-quantum-attacks/10544#10544">2<sup>170</sup></a> 
							collision resistance and 2<sup>256</sup> pre-image resistance against quantum computers.<br>
							<br>
							The program first gets a random index number from an array of available algorithms, then 
							it uses this algorithm to create the MAC. It selects the random array index by using the last byte of 
							the one-time pad. It converts this byte to an integer value (0 - 255), then uses that number modulo 
							the number of MAC algorithms available. Because there are only two MAC algorithms at the moment, that 
							will return an integer of 0 or 1 which references the index of the algorithm in an array.
						</li>
						<li>
							The process is to perform the encryption on the message parts first, then calculate the MAC from the 
							ciphertext and use the one-time pad as the key. This provides integrity of the ciphertext and integrity 
							of the plaintext. Also it does not provide any information on the plaintext since no structure from 
							the plaintext has been carried into the MAC. Skein and Keccak are newer, more secure hash algorithms 
							and do not need complicated constructions like <a href="http://en.wikipedia.org/wiki/HMAC">HMAC</a> 
							to prevent length extension attacks unlike the NSA designed 
							<a href="https://en.wikipedia.org/wiki/Sha1">SHA1</a> and 
							<a href="https://en.wikipedia.org/wiki/Sha2">SHA2</a>. The MAC can be created simply by prepending 
							the message with the key and hashing it, i.e. <span class="formulas"><i>H</i>(<i>K</i> || <i>M</i>)</span>.
						</li>
						<li>
							Finally the MAC tag is encrypted with the last 64 bytes (512 bits) of the one-time pad. This retains the 
							<a href="http://en.wikipedia.org/wiki/Information-theoretically_secure">information-theoretically secure</a> 
							properties for the MAC tag as well as the message. No attacker can know if they have successfully 
							deciphered the encryption by brute forcing combinations of the key to create a valid MAC tag. Nor can 
							an attacker know if they have created a successful forgery when they do not know the correct key.
						</li>
					</ul>
					
					
					<h2 id="auto-nuke-process">Auto nuke process</h2>
					<p>
						The protocol normally erases the one-time pad as soon as a message is sent. The one-time pad is also 
						removed from a receiver's database after they have sucessfully received and authenticated a message. This 
						is a more secure form "off the record" chat similar to the <a href="http://en.wikipedia.org/wiki/Off-the-Record_Messaging">OTR messaging protocol</a>. 
						OTR has good principles but lacks the <a href="https://en.wikipedia.org/wiki/Information-theoretic_security">perfect secrecy</a> 
						and <a href="https://en.wikipedia.org/wiki/Plausible_deniability#Use_in_cryptography">plausible deniability</a> 
						of the one-time pad.
					</p>
					<p>
						One of the key features of the program is being able to instantly and automatically wipe the local 
						database of one-time pads, the server database of encrypted messages, the other user's database of 
						one-time pads and clear any messages remaining on screen.
					</p>
					<p>
						This should be initiated in an emergency situation only. Potentially if a chat group user believes their 
						database of one-time pads may be compromised soon, or 3 letter agencies are inbound on a 
						<a href="http://www.theregister.co.uk/2012/08/08/dotcom_arrest_video/">helicopter assault</a> then they 
						should initiate the auto nuke. This means the users are no longer in possession of the decryption keys so 
						it means they cannot be compelled to <a href="https://www.xkcd.com/538/">produce them under duress</a> or 
						in a court of law. No encryption keys means no way to decrypt past messages. Without the real encryption 
						keys, a user under duress can easily think of any plausible plaintext message for any encrypted message and 
						an aggressor will not know the difference. A simple way to calculate this for a one-time pad, given any 
						ciphertext is to simply create a fake message, convert the ciphertext and fake message to binary, 
						then XOR them together which will produce a plausible key to give to an attacker.
					</p>
				</div>
				<div class="clear"></div>
			</div>
		</div>
		
		<div class="footer">
			<ul class="links">
				<li>
					<a href="index.html">Home</a>
				</li>
				<li>-</li>
				<li>
					<a href="information.html">Technical information</a>
				</li>
				<li>-</li>
				<li>
					<a href="download.html">Download</a>
				</li>
				<li>-</li>
				<li>
					<a href="https://github.com/joshua-m-david/jerichoencryption">Source code</a>
				</li>				
				<li>-</li>
				<li>
					<a href="installation.html">How to install</a>
				</li>
				<li>-</li>
				<li>
					<a href="usage.html">How to use</a>
				</li>
				<li>-</li>
				<li>
					<a href="faq.html">FAQ</a>
				</li>
			</ul>
			<div class="donate">
				Want to support the project?<br>
				Bitcoin: <code>16h8K8sXCobL5u7wKRPG95F8XAc735P8TM</code><br>
				Litecoin: <code>Ld2X3Uyknq87GktF38q2ZQopyevRwC4hji</code>
			</div>
			<div class="copyright">
				Copyright &copy; 2013 - 2015 Joshua M. David
			</div>
		</div>
	</body>
</html>